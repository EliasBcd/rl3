
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

[R.app GUI 1.79 (8095) x86_64-apple-darwin17.0]

[Espace de Travail restauré depuis /Users/yasmine/.RData]
> 
> 
> install.packages('swirl')
--- SVP sélectionnez un miroir CRAN pour cette session ---
essai de l'URL 'https://cran.irsn.fr/bin/macosx/contrib/4.2/swirl_2.4.5.tgz'
Content type 'application/x-gzip' length 348108 bytes (339 KB)
==================================================
downloaded 339 KB


Les packages binaires téléchargés sont dans
	/var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp8jdQN6/downloaded_packages
> 
> 
> library(swirl)

| Hi! I see that you have some variables saved in your workspace. To keep
| things running smoothly, I recommend you clean up before starting swirl.

| Type ls() to see a list of the variables in your workspace. Then, type
| rm(list=ls()) to clear your workspace.

| Type swirl() when you are ready to begin.

> install_course_github("EliasBcd","InitiationR")
Downloading: 76 kB      
> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new,
| call yourself something unique.

What shall I call you? Yasmine

| Thanks, Yasmine. Let's cover a couple of quick housekeeping items before we begin our first lesson. First of all,
| you should know that when you see '...', that means you should press Enter when you are done reading and ready to
| continue.

...  <-- That's your cue to press Enter to continue

| Also, when you see 'ANSWER:', the R prompt (>), or when you are asked to select from a list, that means it's your
| turn to enter a response, then press Enter to continue.

Select 1, 2, or 3 and press Enter 

1: Continue.
2: Proceed.
3: Let's get going!

Sélection : 1

| You can exit swirl and return to the R prompt (>) at any time by pressing the Esc key. If you are already at the prompt,
| type bye() to exit and save your progress. When you exit properly, you'll see a short message letting you know you've done
| so.

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

| Let's get started!

...

| Please choose a course, or type 0 to exit swirl.

1: InitiationR
2: Take me to the swirl course repository!

Sélection : 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Manipulations simples           2: Assignations et objets          3: Types                        
 4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                   
10: Scripts et fonctions           11: Control Flow                   

Sélection : 6

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!
  |                                                                                                                   |   0%

| Cette leçon introduit les opérateurs et opérations logiques dans R.

...
  |====                                                                                                               |   3%
| Comme nous l'avons déjà vu, il y a deux valeurs logiques dans R, aussi appelé valeurs booléennes, TRUE et FALSE. Dans R,
| il est possible de créer des expressions logiques dont le résultat sera TRUE ou FALSE.

...
  |=======                                                                                                            |   6%
| La création d'expressions logiques nécessite des opérateurs logiques. Nous avons déjà vu les opérateurs arithmétiques tel
| que `+`, `-`, `*` et `/`. Le premier opérateur logique à connaître est l'égalité, représenté par deux signes égalités
| `==`. Essayez d'utiliser cet opérateur pour trouver si TRUE et TRUE sont égaux.

> 
> TRUE == TRUE 
[1] TRUE

| Your dedication is inspiring!
  |===========                                                                                                        |   9%
| Tout comme les expressions arithmétiques, les expressions logiques peuvent être regroupées à l'aide de parenthèses et
| indiquer ainsi les priorités de calcul. Par exemple, le résultat de l'expression (TRUE == TRUE) == TRUE sera bien TRUE.

...
  |==============                                                                                                     |  12%
| Testons cette propriété, essayez d'évaluer (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| All that hard work is paying off!
  |==================                                                                                                 |  16%
| L'opérateur d'égalité peut aussi servir à comparer des nombres. Utilisez-le pour savoir si 6 et 7 sont égaux.

> 6 == 7
[1] FALSE

| That's correct!
  |======================                                                                                             |  19%
| Le résultat de l'expression précédente est FALSE, parce 6 est plus petit que 7. Heureusement pour nous, nous pouvons aussi
| tester les inégalités pour savoir si un nombre est plus petit ou plus grand qu'un autre.

...
  |=========================                                                                                          |  22%
| L'opérateur plus petit que `<` teste si le nombre à gauche de l'opérateur est plus petit que le nombre à droite. Tapez une
| expression pour tester si 6 et plus petit que 7.

> 6 > 7
[1] FALSE

| Not quite! Try again. Or, type info() for more options.

| Utilisez l'opérateur 'plus petit que' et tapez 6 < 7.

> 6 < 7
[1] TRUE

| Great job!
  |=============================                                                                                      |  25%
| Il existe aussi un opérateur plus petit ou égal à `<=` qui teste si l'expression à gauche est plus petite ou égale à
| l'expression à droite. Essayez de voir si 10 est plus petit ou égal à 10.

> 10 <= 10
[1] TRUE

| You got it right!
  |================================                                                                                   |  28%
| On peut aussi utiliser les opérateurs plus grand que `>` et plus grand ou égal à `>=`.

...
  |====================================                                                                               |  31%
| Voyons si vous avez compris. Laquelle des expressions suivantes à pour résultat FALSE ?

1: 9 >= 10
2: 0 > -36
3: 7 == 7
4: 6 < 8

Sélection : 1

| That's the answer I was looking for.
  |========================================                                                                           |  34%
| Et maintenant, laquelle des expressions suivantes à pour résultat TRUE ?

1: -6 > -7
2: 7 == 9
3: 57 < 8
4: 9 >= 10

Sélection : 1

| You got it!
  |===========================================                                                                        |  38%
| Intéressons maintenant à l'opérateur 'différent de' (= non-égal) représenté par `!=`. Différent de teste si deux valeurs
| sont différentes, de telle sorte que le résultat de TRUE != FALSE est TRUE. Tout comme l'opérateur égalité, l'opérateur
| différent de s'utilise aussi avec des nombres. Essayez d'écrire une expression pour savoir si 5 est différent de 7.

> 5 != 7
[1] TRUE

| You are quite good my friend!
  |===============================================                                                                    |  41%
| Il peut être utile de 'négativer' une expression avec l'opérateur NON. Un point d'exclamation `!` inversera les
| évaluations de TRUE et FALSE, de telle sorte que la valeur de !TRUE (lire : non TRUE) est FALSE et que la valeur de !FALSE
| (lire : non FALSE) est TRUE. Essayez d'utiliser l'opéraeur NON pour trouver l'inverse de 5 est égal à 7.

> 5 = 7 !
Erreur : '!' inattendu(e) dans "5 = 7 !"
> 5 != 7
[1] TRUE

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Cette question est peut-être un peu difficile, pensez à la négation de l'expression 5 == 7 (vous avez seulement besoin
| d'un point d'exclamation devant).

> 5 == 7 !
Erreur : '!' inattendu(e) dans "5 == 7 !"
> 
> 5 !== 7
Erreur : '=' inattendu(e) dans "5 !=="
> ! 5 == 7
[1] TRUE

| Keep up the great work!
  |==================================================                                                                 |  44%
| Récapitulons. L'opérateur égal `==` teste si deux valeurs sont égales. L'opérateur différent de `!=` teste si deux valeurs
| sont différentes. L'opérateur NON `!` négative une expression logique de telle manière que TRUE devient FALSE et FALSE
| devient TRUE.

...
  |======================================================                                                             |  47%
| Laquelle des expressions suivante est FALSE ?

1: !FALSE
2: 9 < 10
3: !(0 >= -1)
4: 7 != 8

Sélection : 3

| Great job!
  |==========================================================                                                         |  50%
| Quel est à votre avis le résultat de l'expression suivante : (TRUE != FALSE) == !(6 == 7)

1: TRUE
2: Y a-t-il une vérité objective dans la programmation ?
3: FALSE
4: %>%

Sélection : 4

| One more time. You can do it!

| Essayez d'évaluer les expressions indépendamment pour trouver le résultat.

1: %>%
2: TRUE
3: FALSE
4: Y a-t-il une vérité objective dans la programmation ?

Sélection : 2

| Keep up the great work!
  |=============================================================                                                      |  53%
| Il est parfois nécessaire d'examiner les relations entre plusieurs expressions logiques. On utilise pour cela les
| opérateurs ET (AND) et OU (OR).

...
  |=================================================================                                                  |  56%
| Regardons comment l'opérateur ET fonctionne. Il y a deux opérateurs ET dans R, `&` et `&&`. Les deux opérateurs sont
| similaires. Si les expressions à droite et à gauche de l'opérateur ET ont toutes les deux pour résultat TRUE, alors
| l'expression entière a pour résultat TRUE, sinon le résultat est FALSE. Par exemple, la valeur de TRUE & TRUE est TRUE.
| Essayez avec FALSE & FALSE.

> FALSE & FALSE
[1] FALSE

| Excellent job!
  |====================================================================                                               |  59%
| Vous pouvez utilisez l'opérateur `&` pour évaluer ET suivant un vecteur. La version `&&` a besoin d'avoir une seule valeur
| logique à gauche et à droite pour fonctionner. Essayons les deux. Commencez par TRUE & c(TRUE, FALSE, FALSE).

> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| You are doing so well!
  |========================================================================                                           |  62%
| L'expression de gauche est recyclée (rappelez-vous la leçon sur les vecteurs) afin d'avoir la même longueur que le vecteur
| de droite. C'est comme si on avait écrit c(TRUE, TRUE, TRUE) & c(TRUE, FALSE, FALSE). Une expression comme cela
| fonctionnera différemment avec l'opérateur `&&`, R bloquant le recyclage du vecteur de gauche (et renvoit une alerte
| depuis la version 4.2.0).

...
  |===========================================================================                                        |  66%
| Utilisons la même opération en remplaçant `&` par `&&`.

> c(TRUE, TRUE, TRUE) && c(TRUE, FALSE, FALSE)
[1] TRUE
Messages d'avis :
1: Dans c(TRUE, TRUE, TRUE) && c(TRUE, FALSE, FALSE) :
  ‘length(x) = 3 > 1’ dans la conversion automatique vers ‘logical(1)’
2: Dans c(TRUE, TRUE, TRUE) && c(TRUE, FALSE, FALSE) :
  ‘length(x) = 3 > 1’ dans la conversion automatique vers ‘logical(1)’

| You almost had it, but not quite. Try again. Or, type info() for more options.

| Tapez TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE
Message d'avis :
Dans TRUE && c(TRUE, FALSE, FALSE) :
  ‘length(x) = 3 > 1’ dans la conversion automatique vers ‘logical(1)’

| You got it!
  |===============================================================================                                    |  69%
| R nous renvoit un Warning et le résultat ! Un message commençant par Warning est une façon de communiquer pour R. R vous
| communique que l'opération que vous êtes en train de faire est possible (il vous donne un résultat), mais qu'elle lui
| semble suspecte. En fait, ici R utilise uniquement le premier élément du vecteur de droite. Ce comportement est amené à
| disparaître dans les futures versions de R, je ne vous encourage donc pas à l'utiliser. Le principal intérêt de
| l'opérateur `&&` est de vous garantir que le résultat a une longueur de 1. Cela nous servira dans la suite du cours.

...
  |===================================================================================                                |  72%
| L'opérateur OU fonctionne d'une manière similaire. `|` recycle les vecteurs si besoin, alors que `||` renvoit un résultat
| de longueur 1.

...
  |======================================================================================                             |  75%
| OU renvoit TRUE si l'expression de droite ou l'expression de gauche est TRUE. Il renvoit FALSE sinon.

...
  |==========================================================================================                         |  78%
| Testons la version vectorielle de OU. Tapez la commande TRUE | c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| You are doing so well!
  |=============================================================================================                      |  81%
| Les opérateurs logiques peuvent être chainés, tout comme les opérations arithmétiques. Les expressions `6 != 10 && FALSE
| && 1 >= 2` ou `TRUE || 5 < 9.3 || FALSE` sont tout à fait normales.

...
  |=================================================================================================                  |  84%
| Les opérations arithmétiques ont un ordre de priorité. Il en est de même pour les expressions logiques. Tous les
| opérateurs ET sont évalués avant les opérateurs OU. Essayez cet exemple un peu ambigu 5 > 8 || 6 != 8 && 4 > 3.9.

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| Great job!
  |=====================================================================================================              |  88%
| Regardons l'ordre des opérations dans cet exemple. ET est prioritaire sur OU. On commence donc par évaluer les expressions
| à gauche et à droite de &&. 6 est bien différent de 8, donc le résultat à gauche est TRUE. 4 est bien plus grand que 3.9,
| donc le résultat à droite est aussi TRUE. Le résultat de TRUE && TRUE est TRUE. On peut maintenant regarder ce qui se
| passe autour de ||. À droite, on a TRUE, à gauche, 5 n'est pas plus grand que 8, donc le résultat est FALSE. FALSE || TRUE
| a pour résultat TRUE, ce qui nous donne bien le résultat final.

...
  |========================================================================================================           |  91%
| Quelle expression a pour résultat TRUE ?

1: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
2: FALSE || TRUE && FALSE
3: TRUE && FALSE || 9 >= 4 && 3 < 6
4: TRUE && 62 < 62 && 44 >= 44

Sélection : 3

| You are doing so well!
  |============================================================================================================       |  94%
| Quelle expression a pour résultat FALSE ?

1: 6 >= -9 && !(6 > 7) && !(!TRUE)
2: FALSE || TRUE && 6 != 4 || 9 > 4
3: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Sélection : 1

| One more time. You can do it!

| Si vous ne trouvez pas la réponse, essayez chaque expression pour en lire le résultat.

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
3: FALSE || TRUE && 6 != 4 || 9 > 4
4: 6 >= -9 && !(6 > 7) && !(!TRUE)

Sélection : 3

| You almost had it, but not quite. Try again.

| Si vous ne trouvez pas la réponse, essayez chaque expression pour en lire le résultat.

1: FALSE || TRUE && 6 != 4 || 9 > 4
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Sélection : 3

| Keep working like that and you'll get there!
  |===============================================================================================================    |  97%
| C'est la fin de l'introduction à l'évaluation des expressions logiques dans R.

...
  |===================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de
| l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui envoyer le fichier 'Logique.txt'
| qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Nice try, but that's not exactly what I was hoping for. Try again.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 2

| Almost! Try again.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 1

| You are quite good my friend!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: InitiationR
2: Take me to the swirl course repository!

Sélection : 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   

Sélection : 7

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!
  |                                                                                                                                                                                                           |   0%

| Les valeurs manquantes jouent un rôle important en statistiques et en analyse de données. Il arrive que les valeurs manquantes ne doivent pas être ignorée, mais au contraire étudiez avec attention.

...
  |==========                                                                                                                                                                                                 |   5%
| Dans R, les valeurs manquantes sont représentées par la valeur NA (not available en anglais). Dans d'autres langages, cela peut être missing plutôt. Dans cette leçon, nous allons voir comment traiter les
| valeurs manquantes.

...
  |===================                                                                                                                                                                                        |  10%
| N'importe quelle opération dans laquelle NA existe abouti à un résultat NA. Pour illustrer cela, créez le vecteur c(44, NA, 5, NA) et assigné le à l'objet x.

> c(44, NA, 5, NA)<-x
Erreur dans c(44, NA, 5, NA) <- x : 
  la cible de l'assignation est un objet n'appartenant pas au langage
> x <- c(44, NA, 5, NA)

| Your dedication is inspiring!
  |=============================                                                                                                                                                                              |  14%
| Multiplions x par 3.

> x*3
[1] 132  NA  15  NA

| That's the answer I was looking for.
  |=======================================                                                                                                                                                                    |  19%
| Remarquez que dans le résultat affiché, les valeurs NA correspondent aux valeurs où x est lui-même NA.

...
  |================================================                                                                                                                                                           |  24%
| Afin de rendre le problème un peu plus intéressant, nous allons créer un vecteur contenant 1000 tirages issue d'une distribution normale centrée réduite et les assigner à l'objet y. Utilisez pour cela la
| commande y <- rnorm(1000).

>  y <- rnorm(1000)

| Perseverance, that's the answer.
  |==========================================================                                                                                                                                                 |  29%
| Créons maintenant un vecteur contenant 1000 NA avec z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| You are really on a roll!
  |====================================================================                                                                                                                                       |  33%
| Enfin, sélectionnons 100 valeurs provenant des vecteurs y et z au hasard, afin de ne pas savoir combien il y a d'élément manquants dans le vecteur final, ni leur position. Pour cela, on utilise la commande data
| <- sample(c(y, z), 100)

> data <- sample(c(y, z), 100)

| You nailed it! Good job!
  |=============================================================================                                                                                                                              |  38%
| Commençons par identiifer où se trouve nos NA dans les données. La commande is.na() nous dit si chaque élément d'un vecteur est NA. Utilisez is.na() sur data et assignez le résultat à my_na.

> my_na <- is.na(data)

| You're the best!
  |=======================================================================================                                                                                                                    |  43%
| Affichez maintenant my_na.

> my_na
  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE
 [35] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
 [69]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE

| You got it right!
  |=================================================================================================                                                                                                          |  48%
| À chaque fois que vous voyez TRUE, vous savez que l'élément correspondant dans data est une NA. À l'inverse, quand vous voyez FALSE, l'élément correspond est un des nombre issu du tirage aléatoire.

...
  |==========================================================================================================                                                                                                 |  52%
| Dans la leçon sur les opérateurs logiques, nous avons vu l'opérateur égalité `==`. Il test l'égalité entre deux objets. On peut penser que data == NA aboutira au même résultat que is.na(). Essayez pour voir !

> data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [70] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| You got it right!
  |====================================================================================================================                                                                                       |  57%
| Le résultat est un vecteur contenant uniquement des NA. L'explication pour cela est assez simple. NA n'est pas une valeur en soi, mais un symbole qui indique l'absence de valeur. L'opération logique paraît donc
| incomplète à R. On lui demande de comparer une valeur inexistance avec un vecteur de valeurs. Il ne peut que retourner l'absence de valeur.

...
  |==============================================================================================================================                                                                             |  62%
| Les NA peuvent être déroutante au début. Ne vous inquiétez pas si tout n'est pas très clair. Le point important à retenir que quand vous êtes face à des valeurs manquantes (NA), soyez prudent, cela peut vous
| donner des résultats inattendus.

...
  |=======================================================================================================================================                                                                    |  67%
| Fin de la parenthèse. Nous avons un vecteur, my_na, qui prend comme valeur TRUE pour chaque NA dans les données et FALSE pour toutes les valeurs numériques. Nous pouvons calculer le nombre de NA dans notre
| vecteur de données data.

...
  |=================================================================================================================================================                                                          |  71%
| Il y a une astuce qui va nous faire gagner du temps. R traîte les FALSE comme des 0 et les TRUE comme des 1. Il nous suffit donc de calculer la somme totale du vecteur my_na pour connaître le nombre de valeurs
| NA.

...
  |===========================================================================================================================================================                                                |  76%
| Essayons. Utilisez la commande sum() sur le vecteur my_na pour compter le nombre total de TRUE dans my_na, et donc le nombre total de NA dans data. Seul le résultat nous intéresse.

> sum(my_na)
[1] 55

| That's the answer I was looking for.
  |====================================================================================================================================================================                                       |  81%
| Pratique, n'est-ce pas ? Enfin, pour vous convaincre que tout fonctionne bien, regardons les données. Affichez data dans la console.

> data
  [1]  0.3117528497 -0.1210579808            NA            NA -0.5931921483 -1.0412769448 -0.9691137236  2.8365769578            NA            NA -1.5770164362            NA            NA  0.2606211657
 [15]  0.8718965088  1.2898782333            NA -0.8794739091 -0.2487220159            NA            NA            NA            NA -1.5308139300            NA  0.1904389165  0.8849502205            NA
 [29]            NA -0.0009931197            NA            NA            NA            NA -1.1213543605 -0.5119764534 -0.8194914290            NA            NA            NA            NA            NA
 [43] -0.5157774187            NA  0.2814323545 -0.6509095745            NA  0.4000603117  0.7251732142            NA -0.1580613451            NA            NA -1.4493858870            NA  0.4104873339
 [57]            NA            NA            NA            NA -0.2105941405 -0.2822336715            NA            NA  2.1454753595  0.4184426755            NA            NA            NA            NA
 [71]            NA  0.6168823021 -0.8586897055  0.8397331157            NA            NA            NA            NA            NA            NA            NA -0.0639035820 -1.2038233571  1.5069635478
 [85]  0.1051770864  3.1530088315            NA            NA            NA  0.2946915421            NA  0.7544024581 -0.1016573949            NA            NA  0.3413115690 -1.6608929433            NA
 [99] -0.3230212577            NA

| You're the best!
  |==============================================================================================================================================================================                             |  86%
| Il existe un second type de valeurs manquates, NaN (de l'anglais 'not a number'. Pour créer un NaN, essayez de diviser 0 par 0.

> 0/0
[1] NaN

| You got it!
  |========================================================================================================================================================================================                   |  90%
| Une deuxième façon de créer des NaN. R a un symbole pour l'infini mathématiques, Inf. Que se passe-t-il si on soustrait Inf de Inf ?

> Inf - Inf
[1] NaN

| Keep working like that and you'll get there!
  |=================================================================================================================================================================================================          |  95%
| Les NaN sont, vous l'aurez compris, un peu différent des NA. Ils ne nous indiquent pas l'absence de valeur général, mais le fait que le résultat de l'opération demandée n'est pas un nombre (une division par 0)
| et ne peut donc être calculé au sens classique du terme.

...
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui
| envoyer le fichier 'Valeurs_manquantes.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Nice try, but that's not exactly what I was hoping for. Try again.

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 1

| That's not exactly what I'm looking for. Try again.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 1

| All that hard work is paying off!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: InitiationR
2: Take me to the swirl course repository!

Sélection : 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   

Sélection : 8

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!
  |                                                                                                                                                                                                           |   0%

| Nous allons maintenant étudier la création de vecteurs numériques.

...
  |=========                                                                                                                                                                                                  |   4%
| La manière la plus simple de créer un vecteur numérique dans R est d'utiliser la commande `:`. Tapez 1:20 pour voir comment elle fonctionne.

> 1:20
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You got it!
  |==================                                                                                                                                                                                         |   9%
| Nous avons crée un vecteur contenant (et incluant)tous les entiers entre 1 et 20. La commande fonctionne aussi avec des nombres réels. Essayez par exemple pi:10.

> pi:10
[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

| You're the best!
  |==========================                                                                                                                                                                                 |  13%
| Le résultat est un vecteur de nombre réels commençant à pi (3.142...) et croissant par incrément de 1. La limite haute 10 n'est jamais atteinte, puisque le prochain nombre dans la séquence serait strictement
| supérieur à 10.

...
  |===================================                                                                                                                                                                        |  17%
| Que se passe-t-il si nous tapons 15:1 ? Essayez pour voir.

> 15:1
 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

| You are amazing!
  |============================================                                                                                                                                                               |  22%
| R utilise un incrément de -1 ! Ce comportement est parfois utile, gardez-le en tête.

...
  |=====================================================                                                                                                                                                      |  26%
| Pour accéder à l'aide sur une commande, vous pouvez utiliser un point d'interrogation suivi du nom de la commande. Il y a une exception néanmoins, le cas d'un opérateur tel que :. Il est nécessaire de mettre
| l'opérateur entre guillemets, comme ceci : ?':'.

...
  |==============================================================                                                                                                                                             |  30%
| Essayez d'obtenir la documentation pour : maintenant.

> maintenant 
Erreur : objet 'maintenant' introuvable
> ?'maintenant'
Aucune documentation pour ‘maintenant’ n'a été trouvée dans les packages et les bibliothèques :
vous pourriez essayer ‘??maintenant’

| Keep trying! Or, type info() for more options.

| Tapez ?':'.

> ?':'
démarrage du serveur d'aide httpd ... fini

| All that hard work is paying off!
  |=======================================================================                                                                                                                                    |  35%
| Il est parfois utile d'avoir plus de contrôle sur la création de vecteurs numériques que permis par l'opérateur :. La fonction seq() sert exactement à cela.

...
  |===============================================================================                                                                                                                            |  39%
| Dans sa forme la plus simple, seq() remplit exactement le même rôle que `:`. Essayez seq(1, 20).

> seq(1,20)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| That's a job well done!
  |========================================================================================                                                                                                                   |  43%
| Nous avons le même résultat qu'avec 1:20, peu intéressant... Imaginons maintenant que vous souhaitez créer un vecteur de nombre allant de 0 à 10 par incrément de 0.5. seq(0, 10, by=0.5) fait exactement cela.
| Essayez !

> seq(0,10,by=0,5)
Erreur dans seq.default(0, 10, by = 0, 5) : trop d'arguments
> seq(0, 10, by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0

| You're the best!
  |=================================================================================================                                                                                                          |  48%
| Parfois, ce n'est pas l'incrément qui compte, mais d'obtenir un vecteur avec une longueur donnée, par exemple, 30 nombres entre 5 et 10. seq(5, 10, length=30) sert exactement à cela. Essayez et stockez le
| résultat dans un nouvel objet appelé ma_seq.

> seq(5, 10, length=30)
 [1]  5.000000  5.172414  5.344828  5.517241  5.689655  5.862069  6.034483  6.206897  6.379310  6.551724  6.724138  6.896552  7.068966  7.241379  7.413793  7.586207  7.758621  7.931034  8.103448  8.275862
[21]  8.448276  8.620690  8.793103  8.965517  9.137931  9.310345  9.482759  9.655172  9.827586 10.000000

| Not quite right, but keep trying. Or, type info() for more options.

| Vous utilisez exactement la même commande que tout à l'heure, mais avec des arguments différent. Sauvegardez bien le résultat dans un nouvel objet ma_seq, comme ceci ma_seq <- seq(5, 10, length=30).

> ma_seq <- seq(5, 10, length=30)

| Keep up the great work!
  |==========================================================================================================                                                                                                 |  52%
| La fonction length() permet de connaître la longueur d'un objet dans R. Essayez-la sur le vecteur ma_seq pour vérifier qu'il contient bien 30 éléments.

> length(ma_seq)
[1] 30

| All that hard work is paying off!
  |===================================================================================================================                                                                                        |  57%
| Imaginons que nous ne connaissions pas la longueur de ma_seq, mais que nous voulons générer un vecteur de même longueur que le vecteur ma_seq et contenant les N premiers entiers. Autrement nous voulons générer
| un vecteur (1, 2, 3, ... N) ou N est la longueur de ma_seq.

...
  |============================================================================================================================                                                                               |  61%
| Il y a plusieurs manière de faire pour aboutir à ce résultat. La première est de combiner l'opérateur : et la fonction length(), comme ceci : 1:length(ma_seq). Essayez.

> : 1:length(ma_seq)
Erreur : ':' inattendu(e) dans ":"
> 1:length(ma_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| You are doing so well!
  |====================================================================================================================================                                                                       |  65%
| Il est aussi possible d'utiliser une autre option de la fonction seq(), along.with, comme ceci : seq(along.with = ma_seq). L'argument along.with dit à R que vous voulez un vecteur de même longeur que ma_seq.
| Essayez.

> seq(along.with = ma_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| That's a job well done!
  |=============================================================================================================================================                                                              |  70%
| Mieux encore, comme pour beaucoup de tâches courantes, R dispose d'une commande spécifique, la fonction seq_along(). Tapez seq_along(ma_seq) pour la voir en action.

> seq_along(ma_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| That's the answer I was looking for.
  |======================================================================================================================================================                                                     |  74%
| Il y a souvent plusieurs manières de résoudre le même problème dans R. Les approches simples qui requièrent le moins de lignes de code sont généralement les meilleures. Il est aussi important que votre code
| soit lisible pour que d'autres puissent le lire.

...
  |===============================================================================================================================================================                                            |  78%
| Si R dispose d'une fonction spécifique pour la tâche que vous souhaitez accomplir, c'est généralement votre meilleure option. Vous allez apprendre à créer vos propres fonctions quand vous ne trouverez pas ce
| qu'il vous faut dans R. Nous allons en explorer l'écriture dans une prochaine leçon.

...
  |========================================================================================================================================================================                                   |  83%
| Une dernière fonction qui peut être utile pour créer des vecteurs numériques est la fonction rep() (abréviation de "replicate" en anglais). Nous allons examiner quelques possibilités offertes par cette
| fonction.

...
  |=================================================================================================================================================================================                          |  87%
| Si nous voulons créer un vecteur contenant 40 zéros, nous pouvons le faire à l'aide de la commande rep(0, times = 40). Essayez.

> rep(0, times = 40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

| All that hard work is paying off!
  |=========================================================================================================================================================================================                  |  91%
| Une autre utilisation de la fonction rep() est pour créer un vecteur contenant 10 répétition du vecteur (0, 1, 2). Pour cela, tapez rep(c(0, 1, 2), times = 10).

> rep(c(0, 1, 2), times = 10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

| You're the best!
  |==================================================================================================================================================================================================         |  96%
| Enfin, imaginons que plutôt que de répéter le vecteur (0, 1, 2) 10 fois, nous voulons un vecteur qui contiennent 10 zéros, puis 10 un, puis 10 deux. R nous permet de faire ça à l'aide de l'argument each de la
| fonction rep(). Essayez rep(c(0, 1, 2), each = 10).

> rep(c(0, 1, 2), each = 10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

| You are doing so well!
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui
| envoyer le fichier 'Vecteurs_numeriques.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Keep trying!

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 1

| That's not exactly what I'm looking for. Try again.

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 2

| That's the answer I was looking for.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: InitiationR
2: Take me to the swirl course repository!

Sélection : 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   

Sélection : 9

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!
  |                                                                                                                                                                                                           |   0%

| Nous avons vu comment créer des vecteurs contenant différentes valeurs, et différent types de valeurs. Il est parfois utile de les regrouper en une seule base de données. C'est à cela que nous servirons les
| dataframes.

...
  |==========                                                                                                                                                                                                 |   5%
| Nous avons vu que nous pouvons créer un vecteur à l'aide de la commande c(). Reprenez le vecteur contenant les tailles de la leçon précédente. Pour mémoire, nous souhaitons créer le vecteur contenant les
| tailles 156, 164, 197, 147 et 173 (dans cet ordre). Stockez le résultat dans l'objet tailles.

> c(tailles 156, 164, 197, 147, 173)
Erreur : constante numérique inattendue dans "c(tailles 156"
> c(156, 164, 197, 147, 173)
[1] 156 164 197 147 173

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| Tapez tailles <- c(156, 164, 197, 147, 173) et appuyez sur entrée.

> tailles <- c(156, 164, 197, 147, 173)

| You are quite good my friend!
  |===================                                                                                                                                                                                        |  10%
| Recréons maintenant le vecteur poids de la leçon sur les vecteurs. Pour mémoire, nous souhaitons créer le vecteur contenant les poids 45, 59, 110, 44 et 88 (dans cet ordre). Stockez le résultat dans l'objet
| poids.

> poids <- c(45, 59, 110, 44, 88 )

| Great job!
  |=============================                                                                                                                                                                              |  14%
| Nous avons maintenant nos deux vecteurs de données, mais ils ne sont pas vraiment liés entre eux. Nous savons que la première taille correspond au premier poids, la seconde au second, etc. Nous pouvons même
| créer un vecteur de noms associés.

...
  |=======================================                                                                                                                                                                    |  19%
| Attribuons des noms à ces poids et tailles maintenant. Disons que ce sont les caractéristiques de Jeanne, Mohammed, Bassirou, Leila et Zoé. On peut créer un vecteur noms contenant ces noms (sans oublier les
| accents). Faites-le maintenant.

> noms <- c(Jeanne, Mohammed, Bassirou, Leila, Zoé)
Erreur : objet 'Jeanne' introuvable
2022-11-15 14:25:11.443 R[11262:876117] -deltaZ is deprecated for NSEventTypeMagnify.  Please use -magnification.
>  noms <- c(Jeanne, Mohammed, Bassirou, Leila, Zoé)
Erreur : objet 'Jeanne' introuvable
>  noms <- c("Jeanne", "Mohammed", "Bassirou", "Leila", "Zoé")

| You're the best!
  |================================================                                                                                                                                                           |  24%
| Nous n'avons toujours pas liés nos données. Il n'est pas simple de trouver le poids et la taille de Bassirou par exemple. Pour simplifier cela, R possède un type, le data.frame, qui regroupe les données sous forme de
| tableaux.

...
  |==========================================================                                                                                                                                                 |  29%
| Il est possible de donner des noms aux lignes, ou pas. Ici, il est pratique pour nous d'attribuer le nom des personnes aux lignes, mais cela ne sera pas toujours le cas. La commande pour regrouper les données dans un
| tableau est data.frame. Pour ce que nous souhaitons faire, il faut taper data.frame(tailles, poids, row.names=noms). Nous souhaitons de plus stocker le dataframe dans l'objet data.

> data.frame(tailles, poids, row.names=noms)
         tailles poids
Jeanne       156    45
Mohammed     164    59
Bassirou     197   110
Leila        147    44
Zoé          173    88

| Give it another try. Or, type info() for more options.

| N'oubliez pas d'attribuer le dataframe à l'objet data.

> data <- datframe
Erreur : objet 'datframe' introuvable
> datframe <- data

| Give it another try. Or, type info() for more options.

| N'oubliez pas d'attribuer le dataframe à l'objet data.

> info(data)
Erreur dans info(data) : argument inutilisé (data)
> data<-data.frame

| You're close...I can feel it! Try it again. Or, type info() for more options.

| N'oubliez pas d'attribuer le dataframe à l'objet data.

> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> skip()

| Entering the following correct answer for you...

> data <- data.frame(tailles, poids, row.names=noms)

| Keep up the great work!
  |====================================================================                                                                                                                                       |  33%
| Tapons maintenant data pour observer comment R a stocké nos données.

> data
         tailles poids
Jeanne       156    45
Mohammed     164    59
Bassirou     197   110
Leila        147    44
Zoé          173    88

| Perseverance, that's the answer.
  |=============================================================================                                                                                                                              |  38%
| R a stocké tout data dans un seul tableau. Il a automatiquement donné comme nom de colonnes le noms des objets utilisés pour construire le dataframe. Vous remarquerez aussi que les noms ne sont pas précédés d'un nom
| de colonne. C'est parce que c'est l'unique colonne de noms de lignes.

...
  |=======================================================================================                                                                                                                    |  43%
| Si on veut accéder à une colonne de ce tableau, il y a plusieurs méthodes. La première consiste à utiliser le nom du dataframe, suivi du signe $ suivi du nom de la colonne. Essayez de voir les tailles.

> tailles$
+ tailles $
+ $ tailles
Erreur : '$' inattendu(e) dans :
"tailles $
$"
> data.frame(tailles)$
+ data.frame($ tailles)
Erreur : '$' inattendu(e) dans :
"data.frame(tailles)$
data.frame($"
>  data.frame $(tailles)
Erreur : '(' inattendu(e) dans " data.frame $("
> 
> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> skip()

| Entering the following correct answer for you...

> data$tailles
[1] 156 164 197 147 173

| You nailed it! Good job!
  |=================================================================================================                                                                                                          |  48%
| La deuxième permet de consulter n'importe quelle colonne à l'aide d'un indice, un peu comme on consulterait un élément d'un vecteur. Si on souhaite voir la colonne numéro 2 du dataframe, on tapera data[2]. Essayez
| pour voir !

> data[2]
         poids
Jeanne      45
Mohammed    59
Bassirou   110
Leila       44
Zoé         88

| You got it!
  |==========================================================================================================                                                                                                 |  52%
| Enfin, une dernière méthode utile est d'utiliser le nom des colonnes entre des crochets, plutôt que d'utiliser le signe $. La méthode d'accès est similaire à la précédente, sauf qu'au lieu d'utiliser l'indice de la
| colonne, il faut utiliser son nom. Essayez pour voir si vous avez compris.

> data[poids]
Erreur dans `[.data.frame`(data, poids) : 
  colonnes non définies sélectionnées
> data[tailles]
Erreur dans `[.data.frame`(data, tailles) : 
  colonnes non définies sélectionnées
> data[noms]
Erreur dans `[.data.frame`(data, noms) : colonnes non définies sélectionnées
> [noms]
Erreur : '[' inattendu(e) dans "["
> [tailles]
Erreur : '[' inattendu(e) dans "["
> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> skip()

| Entering the following correct answer for you...

> data["poids"]
         poids
Jeanne      45
Mohammed    59
Bassirou   110
Leila       44
Zoé         88

| Nice work!
  |====================================================================================================================                                                                                       |  57%
| Vous verrez qu'à l'usage, il est souvent plus facile d'utiliser le nom de la colonne pour la consulter. La raison est simple, vous ne saurez pas toujours dans quel ordre R ordonné les colonnes et vous allez parfois
| ajouter ou supprimer des colonnes à vos dataframes. Il est beaucoup plus simple de se rappeler du nom d'une colonne plutôt que de son numéro, surtout si celui-ci peut changer. La méthode avec le $ ne permet de
| consulter qu'une seule colonne à la fois. La troisième méthode permet au contraire de consulter plusieurs colonnes simultanément, en mettant tous les noms des colonnes dans un vecteur.

...
  |==============================================================================================================================                                                                             |  62%
| Tout comme les colonnes, il y a plusieurs méthodes pour consulter une ou plusieurs lignes. La plus simple est d'utiliser un numéro de ligne. La syntaxe est un peu différente des colonnes. En effet, en pratique R
| considère les dataframes comme des matrices (objets que nous n'avons pas étudiés), c'est à dire que chaque cellule du tableau est indexé par un numéro de ligne et un numéro de colonne. La ligne est donné par le
| premier indice, alors que la colonne est donné par le deuxième indice. Si on veut consulter la deuxième ligne par exemple, on doit entre data[2, ]. Essayez pour voir !

> 
> data[2, ]
         tailles poids
Mohammed     164    59

| That's a job well done!
  |=======================================================================================================================================                                                                    |  67%
| La virgule suivi de rien indique à R que nous souhaitons consulter toutes les colonnes associées à la deuxième ligne. Si maintenant nous souhaitons seulement consulter la première colonne de la deuxième ligne,
| essayez de deviner comment faire.

> data[2,1]
[1] 164

| Keep working like that and you'll get there!
  |=================================================================================================================================================                                                          |  71%
| Nous avons donné des noms au lignes précédemment. Il serait dommage de ne pas les utiliser. Si maintenant on veut retrouver les caractéristiques de Bassirou, on peut utiliser le nom de la ligne, comme nous avons
| utiliser le nom de la colonne. Essayez pour voir si vous avez compris.

> data[3, ]
         tailles poids
Bassirou     197   110

| Almost! Try again. Or, type info() for more options.

| Rappelez-vous de bien mettre des guillemets autour des noms et que vous voulez consulter toutes les colonnes !

> data["Bassirou", ]
         tailles poids
Bassirou     197   110

| You are really on a roll!
  |===========================================================================================================================================================                                                |  76%
| Il est bien sûr possible d'ajouter des colonnes à un dataframe après sa création. Si par exemple nous voulons ajouter la colonne imc à ce dataframe et refaire le calcul fait auparavant, il faut utiliser la syntaxe
| data$imc <- data$poids / (data$tailles / 100)^2. Les règles de calculs sur les lignes ou les colonnes de dataframe sont identiques à celle des vecteurs. On peut aussi appeler les colonnes avec des guillemets et des
| crochets, mais ce n'est pas très utile ici.

> data$imc <- data$poids / (data$tailles / 100)^2

| Your dedication is inspiring!
  |====================================================================================================================================================================                                       |  81%
| Observez maitenant data.

> data
         tailles poids      imc
Jeanne       156    45 18.49112
Mohammed     164    59 21.93635
Bassirou     197   110 28.34394
Leila        147    44 20.36189
Zoé          173    88 29.40292

| All that practice is paying off!
  |==============================================================================================================================================================================                             |  86%
| Remarquez que R a créé une nouvelle colonne, imc, qui est le résultat du calcul que nous lui avons demandé.

...
  |========================================================================================================================================================================================                   |  90%
| Il pourrait être intéressant de faire quelques statistiques sur les données que nous avons. Utilisez la fonction summary() de R surdata pour obtenir un résumé des caractéristiques de notre échantillon.

> summary()
Erreur dans is.factor(object) : 
  l'argument "object" est manquant, avec aucune valeur par défaut
> summary(data)
    tailles          poids            imc       
 Min.   :147.0   Min.   : 44.0   Min.   :18.49  
 1st Qu.:156.0   1st Qu.: 45.0   1st Qu.:20.36  
 Median :164.0   Median : 59.0   Median :21.94  
 Mean   :167.4   Mean   : 69.2   Mean   :23.71  
 3rd Qu.:173.0   3rd Qu.: 88.0   3rd Qu.:28.34  
 Max.   :197.0   Max.   :110.0   Max.   :29.40  

| Nice work!
  |=================================================================================================================================================================================================          |  95%
| Ce sera tout sur cette leçon. Vous savez maintenant l'essentiel des principaux types que vous allez rencontrer dans R.

...
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui envoyer
| le fichier 'Dataframes.txt' qui a été créé plus tard.

1: Oui
2: Non

Sélection : 1

| Not exactly. Give it another go.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 1

| You nailed it! Good job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: InitiationR
2: Take me to the swirl course repository!

Sélection : 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   

Sélection : 10

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!
  |                                                                                                                                                                                                                 |   0%

| Jusqu’ici on a utilisé R de manière "interactive", en saisissant des commandes directement dans la console. Ce n'est pas très pratique pour sauvegarder son travail. Lorsque R ou RStudio redémarre, tout ce qui a été
| effectué dans la console est perdu.

...
  |=====                                                                                                                                                                                                            |   2%
| On va plutôt regrouper les commandes dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées. En rouvrant les scripts et en réexécutant les commandes qu’ils
| contiennent on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats. Pour créer un script, il suffit de sélectionner le menu Fichier (File), puis Nouveau fichier (New File)
| et script R (R script). Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de
| disquette ou en choisissant Fichier (File) puis Sauvegarder (Save) ou en utilisant le raccourci Ctrl + S (Cmd + S sous Mac).

...
  |==========                                                                                                                                                                                                       |   5%
| Un script est un fichier texte brut qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne. Pour exécuter
| une commande dans un script, il faut positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut
| aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut aussi sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble
| des lignes est exécuté d’un coup.

...
  |===============                                                                                                                                                                                                  |   7%
| Vous allez maintenant créer votre premier script. Il contiendra une assignation du vecteur c(156, 164, 197, 147, 173) à l'objet tailles. Puis une assignation du vecteur c(45, 59, 110, 44, 88) au vecteur poids. Puis
| un calcul de l'imc des à l'aide des vecteurs précédent et l'assignation du résultat à l'objet imc. swirl va automatiquement ouvrir une fenêtre avec un script pour cet exercice. Essayez de modifier le script qui va
| s'afficher. Une fois cela fait, vous devez tapez submit() dans l'invite de commande pour soumettre votre réponse.

> 
> 
> 
> 
> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> bye()

| Leaving swirl now. Type swirl() to resume.

> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new, call yourself something unique.

What shall I call you? Yasmine

| Would you like to continue with one of these lessons?

1: Initiation à R Scripts et fonctions
2: No. Let me start something new.

Sélection : 1

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!



| Vous allez maintenant créer votre premier script. Il contiendra une assignation du vecteur c(156, 164, 197, 147, 173) à l'objet tailles. Puis une assignation du vecteur c(45, 59, 110, 44, 88) au vecteur poids. Puis
| un calcul de l'imc des à l'aide des vecteurs précédent et l'assignation du résultat à l'objet imc. swirl va automatiquement ouvrir une fenêtre avec un script pour cet exercice. Essayez de modifier le script qui va
| s'afficher. Une fois cela fait, vous devez tapez submit() dans l'invite de commande pour soumettre votre réponse.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp8jdQN6/imc.R:11:0: fin d'entrée inattendue
9: 
10: imc <- 
   ^

| Almost! Try again.

| Lisez bien les instructions dans le script et complétez-le à l'aide des
| valeurs indiquées.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp8jdQN6/imc.R:11:0: fin d'entrée inattendue
9: 
10: imc <- 
   ^

| Not quite, but you're learning! Try again.

| Lisez bien les instructions dans le script et complétez-le à l'aide des
| valeurs indiquées.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| Excellent work!
  |===================                                                                                                                                                                                              |   9%
| Vous devez avoir remarqué dans le script les lignes qui commençaient par un signe dièse #. Ces lignes indiquent un commentaire dans R et ne sont pas prises en compte dans l'évaluation du script. Les commentaires sont
| une partie très importante d'un script (et des fonctions que nous allons voir). Ils permettent de documenter les actions du script (ou de la fonction) afin de dire ce qu'il fait. On peut ainsi retrouver son code des
| jours ou des mois plus tard et se rappeler de ce qu'on a voulu faire.

...
  |========================                                                                                                                                                                                         |  12%
| Passons maintenant aux fonctions. Les fonctions sont une composante essentielle de R. C'est un petit morceau de code qui peut être traité comme n'importe quel objet R. Vous avez déjà rencontré des fonctions dans ce
| cours. Les fonctions se repèrent généralement par le nom de la fonction suivi de parenthèses.

...
  |=============================                                                                                                                                                                                    |  14%
| Essayons déjà une fonction simple, incluse dans le text. La fonction Sys.Date() renvoit une chaîne de caractères avec la date du jour. Tapez Sys.Date() pour voir ce qu'il se produit.

> Sys.Date()
[1] "2022-11-15"

| You got it!
  |==================================                                                                                                                                                                               |  16%
| La plupart des fonctions dans R renvoient une valeur. Des fonctions telles que Sys.Date() envoit comme résultat une valeur qui dépend de votre ordinateur. D'autres fonctions, au contraire, manipulent des données afin
| de calculer un résultat.

...
  |=======================================                                                                                                                                                                          |  19%
| La fonction mean() prend comme valeur d'entrée (ou argument) un vecteur et calcule la moyenne des éléments de ce vecteur. On dit souvent qu'on passe un argument à une fonction pour dire qu'on l'utilise comme valeur
| d'entrée. Les arguments sont écrits entre les parenthèses. Essayez de passer le vecteur c(2, 4, 5) comme argument à la fonction mean().

> mean(c(2, 4, 5))
[1] 3.666667

| Great job!
  |============================================                                                                                                                                                                     |  21%
| Les fonctions prennent généralement comme arguments des valeurs sur lesquelles elles opèrent des calculs. La fonction mean(), par exemple, prend comme argument un vecteur, comme dans le cas précédent. La fonction
| mean() somme ensuite tous les nombres du vecteurs et divise cette somme par la longueur du vecteur.

...
  |=================================================                                                                                                                                                                |  23%
| Dans la question suivante, je vais vous demander de modifier un script, comme au tout début de cette leçon. Quand vous aurez fini de modifier le script, n'oubliez pas de sauvegarder votre script puis de taper
| submit() pour faire évaluer votre réponse. Il y aura des commentaires dans le script, lisez-les attentivement !

...
  |=====================================================                                                                                                                                                            |  26%
| La dernière expression évaluée dans une fonction est la valeur retournée par la fonction, le résultat de la fonction. Nous voulons que cette fonction prenne un argument, x, et de nous renvoyer comme résultat cet
| argument non modifié. Effacez le # dans le script pour faire en sorte que l'argument soit renvoyé tel que. N'oubliez pas de sauvegardez et tapez sur submit().

> submit()

| Sourcing your script...


| Not quite! Try again.

| N'oubliez pas d'enlever le signe # de commentaire et de ne laisser que x sur la ligne.

> submit()

| Sourcing your script...


| One more time. You can do it!

| N'oubliez pas d'enlever le signe # de commentaire et de ne laisser que x sur la ligne.

> submit()

| Sourcing your script...


| Not exactly. Give it another go.

| N'oubliez pas d'enlever le signe # de commentaire et de ne laisser que x sur la ligne.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| Keep up the great work!
  |==========================================================                                                                                                                                                       |  28%
| Maintenant que vous avez créer votre première fonction, essayons-la ! Tapez boring_function('Hello World!'). Si votre fonction fonctionne correctement, vous devriez voir apparaître comme résultat 'Hello World!'

> boring_function('Hello World!')
[1] "Hello World!"

| You're the best!
  |===============================================================                                                                                                                                                  |  30%
| Félicitations ! Vous avez écrit votre première fonction. Les fonctions sont un élément clé de R avec les objets. Pour comprendre le fonctionnement de R, deux choses sont importantes. Premièrement, tout ce qui existe
| est un objet. Deuxièmement, tout ce qui se produit est une fonction. (Citation de John Chambers, un des créateur de R).

...
  |====================================================================                                                                                                                                             |  33%
| Si vous voulez connaître le code de calcul d'une fonction, tapez son nom sans parenthèses ni arguments. Essayez pour la fonction boring_function.

> boring_function
function(x) {
  x
}
<bytecode: 0x7f836e8f4530>

| You are amazing!
  |=========================================================================                                                                                                                                        |  35%
| Faisons une fonction un peu plus utile. Reproduisons le résultat de la fonction mean() dans une fonction appelée my_mean(). Rappelez-vous que la moyenne est la somme de tous les nombres dans le vecteur divisé par sa
| longuer.

...
  |==============================================================================                                                                                                                                   |  37%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> sum()
[1] 0
> sum(my_mean)
Erreur dans sum(my_mean) : 'type' (closure) de l'argument incorrect
> sum('my_mean')
Erreur dans sum("my_mean") : 'type' (character) de l'argument incorrect
> 
> sum("my_mean")
Erreur dans sum("my_mean") : 'type' (character) de l'argument incorrect
> sum(lenght)
Erreur : objet 'lenght' introuvable
> sum("lenght")
Erreur dans sum("lenght") : 'type' (character) de l'argument incorrect
> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You are really on a roll!
  |===================================================================================                                                                                                                              |  40%
| Testez maintenant votre fonction my_mean() en trouvant la moyenne de du vecteur c(4, 5, 10).

> mean(c)
[1] NA
Message d'avis :
Dans mean.default(c) :
  l'argument n'est ni numérique, ni logique : renvoi de NA

| That's not the answer I was looking for, but try again. Or, type info() for more options.

| Tapez my_mean(c(4, 5, 10)) pour tester votre nouvelle fonction.

> my_mean(c(4, 5, 10))
[1] 6.333333

| All that practice is paying off!
  |=======================================================================================                                                                                                                          |  42%
| Essayons maintenant d'écrire une fonction avec des arguments par défaut. Il est parfois utile de fixer une valeur par défaut pour des arguments d'une fonction. Par exemple si votre fonction va utiliser la même valeur
| très souvent.

...
  |============================================================================================                                                                                                                     |  44%
| Sauvegardez bien votre script avant de taper submit().

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You are really on a roll!
  |=================================================================================================                                                                                                                |  47%
| Testons un petit peu le comportement de la fonction remainder. Tapez remainder(5) et observez le résultat.

> remainder(5)
[1] 1

| Excellent work!
  |======================================================================================================                                                                                                           |  49%
| Observons ce qu'il s'est passé. Vous avez passé un argument à la fonction. R a décidé que cette argument était 'num', puisque 'num' est le premier argument de la fonction. La valeur par défaut pour 'divisor' est 2, R
| a donc utilisé cette valeur dans le calcul.

...
  |===========================================================================================================                                                                                                      |  51%
| Observons maintenant le comportement de remainder avec 2 arguments. Tapez remainder(11, 5) et observons le résultat.

> remainder(11, 5)
[1] 1

| That's a job well done!
  |================================================================================================================                                                                                                 |  53%
| R a utilisé le premier argument pour 'num' et le deuxième pour 'divisor'. C'est bien le comportement attendu.

...
  |=====================================================================================================================                                                                                            |  56%
| Il est aussi possible de spécifier explicitement les arguments avec leur nom. Quand vous procédez ainsi, l'ordre des arguments devient sans importance. Essayez en tapant remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| Nice work!
  |==========================================================================================================================                                                                                       |  58%
| Il y a une grande différence entre remainder(11, 5) et remainder(divisor = 11, num = 5).

...
  |==============================================================================================================================                                                                                   |  60%
| R peut aussi partiellement appairer valeurs et arguments. Tapez remainder(4, div = 2) et observer le résultat.

> 
> remainder(4, div = 2)
[1] 0

| You are quite good my friend!
  |===================================================================================================================================                                                                              |  63%
| Vous voulez en général faire en sorte que votre code soit lisible et compréhensible. Mélanger l'ordre des arguments en utilisant leur nom ou appairer seulement une partie des arguments n'est pas une bonne pratique.
| Faites-le avec parcimonie.

...
  |========================================================================================================================================                                                                         |  65%
| En parlant d'arguments, vous vous demandez peut-être comment on peut découvrir tous les arguments d'une fonction. Fort heureusement, R a une fonction pour ça, args(). Utilisez args() pour connaître les arguments de
| remainder.

> args(remainder)
function (num, divisor = 2) 
NULL

| Great job!
  |=============================================================================================================================================                                                                    |  67%
| Vous ne vous en êtes peut-être pas rendu compte, mais vous venez de faire quelque chose d'intéressant. Vous avez utilisé comme argument d'une fonction une autre fonction ! Et oui, il est possible d'utiliser comme
| argument d'une fonction une autre fonction. Ecrivons un petit script pour explorer cette possibilité.

...
  |==================================================================================================================================================                                                               |  70%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| Almost! Try again.

| Faites bien attention à ne pas mettre de parenthèses à la fonction que vous utilisez comme argument.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| All that practice is paying off!
  |=======================================================================================================================================================                                                          |  72%
| Utilisons maintenant votre fonction evaluate() pour trouver l'écart type du vecteur c(1.4, 3.6, 7.9, 8.8).

> evaluate(c(1.4, 3.6, 7.9, 8.8))
Erreur dans func(dat) : impossible de trouver la fonction "func"
> submit()

| Sourcing your script...


| Not quite, but you're learning! Try again. Or, type info() for more options.

| La fonction écart-type dans R est la fonction sd(). N'oubliez pas que pour passer une fonction en argument il ne faut pas mettre de parenthèses à cette fonction.

> submit()

| Sourcing your script...


| Not exactly. Give it another go. Or, type info() for more options.

| La fonction écart-type dans R est la fonction sd(). N'oubliez pas que pour passer une fonction en argument il ne faut pas mettre de parenthèses à cette fonction.

> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway! Or, type info() for more options.

| La fonction écart-type dans R est la fonction sd(). N'oubliez pas que pour passer une fonction en argument il ne faut pas mettre de parenthèses à cette fonction.

> skip()

| Entering the following correct answer for you...

> evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| Keep up the great work!
  |============================================================================================================================================================                                                     |  74%
| L'idée d'utiliser une fonction comme argument dans une autre fonction est un concept clé de programmation. Encore plus fort : il est possible de passer des fonctions en arguments dans une autre fonction sans avoir
| défini la fonction auparavant. Les fonctions de ce type sont appelées fonctions anonymes (ou lambda fonctions).

...
  |================================================================================================================================================================                                                 |  77%
| Nous allons utiliser la fonction evaluate pour étudier le fonctionnement des fonctions anonymes. Comme premier argument à evaluate, nous allons écrire une petite fonction, qui tient sur une ligne. Comme second
| argument à la fonction evaluate nous allons utiliser comme argument un tout petit ensemble de données.

...
  |=====================================================================================================================================================================                                            |  79%
| Tapez la commande suivante, nous allons voir par la suite comment elle fonctionne : evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| You're the best!
  |==========================================================================================================================================================================                                       |  81%
| Le premier argument d'evaluate est une fonction anonyme très simple qui prend comme argument 'x' et retourne 'x+1'. Nous avons dit à evaluate de passer comme argument 6 à cette fonction, le résultat est donc 7.

...
  |===============================================================================================================================================================================                                  |  84%
| Essayez d'utiliser evaluate() avec une fonction anonyme afin qu'elle retourne le premier élément d'un vecteur. Votre fonction anonyme devrait prendre un seul argument, qui devrait être la variable x. Le vecteur que
| vous devez utiliser pour tester cette fonction doit être le vecteur c(8, 4, 0).

> evaluate(c(8, 4, 0))
Erreur dans func(dat) : impossible de trouver la fonction "func"
> une_fonction
Erreur : objet 'une_fonction' introuvable
> # une_fonction <- function(fonc){
> # une_fonction <- function(fonc){
> une_fonction
Erreur : objet 'une_fonction' introuvable
> evaluate(une_fonction)
Erreur dans evaluate(une_fonction) : objet 'une_fonction' introuvable
> # une_fonction <- function(fonc){
> evaluate(une_fonction)
Erreur dans evaluate(une_fonction) : objet 'une_fonction' introuvable
> # F1<- function(fonc){
> evaluate(une_fonction)
Erreur dans evaluate(une_fonction) : objet 'une_fonction' introuvable
> evaluate(F1)
Erreur dans evaluate(F1) : objet 'F1' introuvable
> # F1<- func(fonc){
> evaluate(F1)
Erreur dans evaluate(F1) : objet 'F1' introuvable
> # F1<- function(c) {
> evaluate(F1)
Erreur dans evaluate(F1) : objet 'F1' introuvable
> skip()

| Entering the following correct answer for you...

> evaluate(function(x){x[1]}, c(8, 4, 0))
[1] 8

| Excellent job!
  |====================================================================================================================================================================================                             |  86%
| Utilisez maintenant la fonction evaluate() et une fonction anonyme afin de retourner le dernier élément d'un vecteur. Votre fonction anonyme ne doit avoir qu'un seul argument qui sera x. Le vecteur que vous devez
| utiliser pour tester cette fonction doit être le vecteur c(8, 4, 0).

> evaluate(function{x[1]}(x), c(8, 4, 0))
Erreur : '{' inattendu(e) dans "evaluate(function{"
> evaluate(function(x){x}, c(8, 4, 0))
[1] 8 4 0

| Almost! Try again. Or, type info() for more options.

| Rappelez vous comment on fait appel à un élément particulier dans un vecteur à l'aide de son index. Votre fonction anonyme ne doit avec qu'un seul argument et le nom de cette argument doit être x. La fonction
| length() peut être utile dans votre fonctio anonyme.

> lenght(evaluate(function(x){x}, c(8, 4, 0)))
Erreur dans lenght(evaluate(function(x) { : 
  impossible de trouver la fonction "lenght"
> skip()

| Entering the following correct answer for you...

> evaluate(function(x){x[length(x)]}, c(8, 4, 0))
[1] 0

| Great job!
  |=========================================================================================================================================================================================                        |  88%
| Jusqu'à la fin de cette leçon nous allons utiliser la fonction paste() fréquemment. Tapez ?paste pour lire la documentation de cette fonction et comprendre son fonctionnement.

> ?paste

| That's a job well done!
  |==============================================================================================================================================================================================                   |  91%
| Afin de comprendre comment paste() fonctionne, essayez de taper paste("La", "programmation", "c'est", "facile !").

> paste("La", "programmation", "c'est", "facile !")
[1] "La programmation c'est facile !"

| That's correct!
  |==================================================================================================================================================================================================               |  93%
| Ecrivons maintenant notre propre version de paste().

...
  |=======================================================================================================================================================================================================          |  95%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| You almost had it, but not quite. Try again.

| N'oubliez pas que des arguments peuvent être donnés après ...

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| You got it right!
  |============================================================================================================================================================================================================     |  98%
| Nous avons fini cette leçon. Vous avez maintenant un des concepts les plus important de R et du monde de la programmation, les fonctions.

...
  |=================================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui envoyer
| le fichier 'Scripts_et_fonctions.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| You almost had it, but not quite. Try again.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 2

| That's not exactly what I'm looking for. Try again.

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 1

| Give it another try.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 2

| Try again. Getting it right on the first try is boring anyway!

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 