
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

[R.app GUI 1.79 (8095) x86_64-apple-darwin17.0]

[Espace de Travail restauré depuis /Users/yasmine/.RData]
[Historique recherché depuis /Users/yasmine/.Rapp.history]

> install.packages('swirl')
--- SVP sélectionnez un miroir CRAN pour cette session ---
essai de l'URL 'https://cran.irsn.fr/bin/macosx/contrib/4.2/swirl_2.4.5.tgz'
Content type 'application/x-gzip' length 348108 bytes (339 KB)
==================================================
downloaded 339 KB


Les packages binaires téléchargés sont dans
	/var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/downloaded_packages
> library(swirl)

| Hi! I see that you have some variables saved in your workspace. To keep things running smoothly, I recommend you clean up before starting swirl.

| Type ls() to see a list of the variables in your workspace. Then, type rm(list=ls()) to clear your workspace.

| Type swirl() when you are ready to begin.

> install_course_github("EliasBcd","InitiationR")
Downloading: 93 kB     
> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new, call yourself something unique.

What shall I call you? Yasmine

| Thanks, Yasmine. Let's cover a couple of quick housekeeping items before we begin our first lesson. First of all, you should know that when you see '...', that means you should press Enter when you are done reading
| and ready to continue.

...  <-- That's your cue to press Enter to continue

| Also, when you see 'ANSWER:', the R prompt (>), or when you are asked to select from a list, that means it's your turn to enter a response, then press Enter to continue.

Select 1, 2, or 3 and press Enter 

1: Continue.
2: Proceed.
3: Let's get going!

Sélection : 1

| You can exit swirl and return to the R prompt (>) at any time by pressing the Esc key. If you are already at the prompt, type bye() to exit and save your progress. When you exit properly, you'll see a short message
| letting you know you've done so.

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

| Let's get started!

...

| Please choose a course, or type 0 to exit swirl.

1: InitiationR
2: Take me to the swirl course repository!

Sélection : 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   
13: Tirages aleatoires             

Sélection : 10

| Attempting to load lesson dependencies...

| Package ‘base64enc’ loaded correctly!
  |                                                                                                                                                                                                                 |   0%

| Jusqu’ici on a utilisé R de manière "interactive", en saisissant des commandes directement dans la console. Ce n'est pas très pratique pour sauvegarder son travail. Lorsque R ou RStudio redémarre, tout ce qui a été
| effectué dans la console est perdu.

...
  |====                                                                                                                                                                                                             |   2%
| On va plutôt regrouper les commandes dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées. En rouvrant les scripts et en réexécutant les commandes qu’ils
| contiennent on pourra “reproduire” le chargement des données, leur traitement, les analyses et leurs résultats. Pour créer un script, il suffit de sélectionner le menu Fichier (File), puis Nouveau fichier (New File)
| et script R (R script). Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de
| disquette ou en choisissant Fichier (File) puis Sauvegarder (Save) ou en utilisant le raccourci Ctrl + S (Cmd + S sous Mac).

...
  |========                                                                                                                                                                                                         |   4%
| Un script est un fichier texte brut qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne. Pour exécuter
| une commande dans un script, il faut positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut
| aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut aussi sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble
| des lignes est exécuté d’un coup.

...
  |=============                                                                                                                                                                                                    |   6%
| Vous allez maintenant créer votre premier script. Il contiendra une assignation du vecteur c(156, 164, 197, 147, 173) à l'objet tailles. Puis une assignation du vecteur c(45, 59, 110, 44, 88) au vecteur poids. Puis
| un calcul de l'imc des à l'aide des vecteurs précédent et l'assignation du résultat à l'objet imc. swirl va automatiquement ouvrir une fenêtre avec un script pour cet exercice. Essayez de modifier le script qui va
| s'afficher. Une fois cela fait, vous devez tapez submit() dans l'invite de commande pour soumettre votre réponse.

2022-12-11 22:08:13.999 R[24761:2613551] -deltaZ is deprecated for NSEventTypeMagnify.  Please use -magnification.
> submit()

| Sourcing your script...

Error in eval(ei, envir) : objet 'taille' introuvable

| Excellent work!
  |=================                                                                                                                                                                                                |   8%
| Vous devez avoir remarqué dans le script les lignes qui commençaient par un signe dièse #. Ces lignes indiquent un commentaire dans R et ne sont pas prises en compte dans l'évaluation du script. Les commentaires sont
| une partie très importante d'un script (et des fonctions que nous allons voir). Ils permettent de documenter les actions du script (ou de la fonction) afin de dire ce qu'il fait. On peut ainsi retrouver son code des
| jours ou des mois plus tard et se rappeler de ce qu'on a voulu faire.

...
  |=====================                                                                                                                                                                                            |  10%
| Passons maintenant aux fonctions. Les fonctions sont une composante essentielle de R. C'est un petit morceau de code qui peut être traité comme n'importe quel objet R. Vous avez déjà rencontré des fonctions dans ce
| cours. Les fonctions se repèrent généralement par le nom de la fonction suivi de parenthèses.

...
  |=========================                                                                                                                                                                                        |  12%
| Essayons déjà une fonction simple, incluse dans le text. La fonction Sys.Date() renvoit une chaîne de caractères avec la date du jour. Tapez Sys.Date() pour voir ce qu'il se produit.

> Sys.Date()
[1] "2022-12-11"

| You got it!
  |=============================                                                                                                                                                                                    |  14%
| La plupart des fonctions dans R renvoient une valeur. Des fonctions telles que Sys.Date() envoit comme résultat une valeur qui dépend de votre ordinateur. D'autres fonctions, au contraire, manipulent des données afin
| de calculer un résultat.

...
  |=================================                                                                                                                                                                                |  16%
| La fonction mean() prend comme valeur d'entrée (ou argument) un vecteur et calcule la moyenne des éléments de ce vecteur. On dit souvent qu'on passe un argument à une fonction pour dire qu'on l'utilise comme valeur
| d'entrée. Les arguments sont écrits entre les parenthèses. Essayez de passer le vecteur c(2, 4, 5) comme argument à la fonction mean().

> mean()<-c(2, 4, 5)
Erreur dans mean() <- c(2, 4, 5) : 
  partie gauche de l'assignation (NULL) incorrect
> mean(c(2, 4, 5))
[1] 3.666667

| That's the answer I was looking for.
  |======================================                                                                                                                                                                           |  18%
| Les fonctions prennent généralement comme arguments des valeurs sur lesquelles elles opèrent des calculs. La fonction mean(), par exemple, prend comme argument un vecteur, comme dans le cas précédent. La fonction
| mean() somme ensuite tous les nombres du vecteurs et divise cette somme par la longueur du vecteur.

...
  |==========================================                                                                                                                                                                       |  20%
| Dans la question suivante, je vais vous demander de modifier un script, comme au tout début de cette leçon. Quand vous aurez fini de modifier le script, n'oubliez pas de sauvegarder votre script puis de taper
| submit() pour faire évaluer votre réponse. Il y aura des commentaires dans le script, lisez-les attentivement !

...
  |==============================================                                                                                                                                                                   |  22%
| La dernière expression évaluée dans une fonction est la valeur retournée par la fonction, le résultat de la fonction. Nous voulons que cette fonction prenne un argument, x, et de nous renvoyer comme résultat cet
| argument non modifié. Effacez le # dans le script pour faire en sorte que l'argument soit renvoyé tel que. N'oubliez pas de sauvegardez et tapez sur submit().

> submit()

| Sourcing your script...


| Keep working like that and you'll get there!
  |==================================================                                                                                                                                                               |  24%
| Maintenant que vous avez créer votre première fonction, essayons-la ! Tapez boring_function('Hello World!'). Si votre fonction fonctionne correctement, vous devriez voir apparaître comme résultat 'Hello World!'

> boring_function('Hello World!')
[1] "Hello World!"

| All that hard work is paying off!
  |======================================================                                                                                                                                                           |  26%
| Félicitations ! Vous avez écrit votre première fonction. Les fonctions sont un élément clé de R avec les objets. Pour comprendre le fonctionnement de R, deux choses sont importantes. Premièrement, tout ce qui existe
| est un objet. Deuxièmement, tout ce qui se produit est une fonction. (Citation de John Chambers, un des créateur de R).

...
  |===========================================================                                                                                                                                                      |  28%
| Si vous voulez connaître le code de calcul d'une fonction, tapez son nom sans parenthèses ni arguments. Essayez pour la fonction boring_function.

> boring_function
function(x) {
  x
}
<bytecode: 0x7f9aba304928>

| You are quite good my friend!
  |===============================================================                                                                                                                                                  |  30%
| Faisons une fonction un peu plus utile. Reproduisons le résultat de la fonction mean() dans une fonction appelée my_mean(). Rappelez-vous que la moyenne est la somme de tous les nombres dans le vecteur divisé par sa
| longueur.

...
  |===================================================================                                                                                                                                              |  32%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/my_mean.R:21:39: symbole inattendu
20: my_mean <- function(my_vector) {
21:   sum(c(2, 4, 5)) / length(c(2, 4, 5)).
                                          ^

| You almost had it, but not quite. Try again.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/my_mean.R:21:37: symbole inattendu
20: my_mean <- function(my_vector) {
21: sum(c(2, 4, 5)) / length(c(2, 4, 5)).
                                        ^

| Not exactly. Give it another go.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/my_mean.R:22:37: symbole inattendu
21:         
22: sum(c(2, 4, 5)) / length(c(2, 4, 5)).
                                        ^

| Give it another try.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| That's not exactly what I'm looking for. Try again.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| Not quite, but you're learning! Try again.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| Give it another try.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| Not quite right, but keep trying.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> sybmit()
Erreur dans sybmit() : impossible de trouver la fonction "sybmit"
> submit()

| Sourcing your script...


| Nice try, but that's not exactly what I was hoping for. Try again.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| Not quite, but you're learning! Try again.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> submit()

| Sourcing your script...


| You almost had it, but not quite. Try again.

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> SUBMIT()
Erreur dans SUBMIT() : impossible de trouver la fonction "SUBMIT"
> submit()

| Sourcing your script...


| Try again. Getting it right on the first try is boring anyway!

| Utilisew la fonction sum() pour trouver la somme de tous les vecteurs d'une fonction et la fonction length pour trouver la taille du vecteur.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| That's the answer I was looking for.
  |=======================================================================                                                                                                                                          |  34%
| Testez maintenant votre fonction my_mean() en trouvant la moyenne de du vecteur c(4, 5, 10).

> my_mean(c(4, 5, 10))
[1] 6.333333

| Keep up the great work!
  |===========================================================================                                                                                                                                      |  36%
| Essayons maintenant d'écrire une fonction avec des arguments par défaut. Il est parfois utile de fixer une valeur par défaut pour des arguments d'une fonction. Par exemple si votre fonction va utiliser la même valeur
| très souvent.

...
  |===============================================================================                                                                                                                                  |  38%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| Keep trying!

| N'oubliez pas de mettre les valeurs par défaut.

> submit()

| Sourcing your script...


| That's not the answer I was looking for, but try again.

| N'oubliez pas de mettre les valeurs par défaut.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/remainder.R:38:1: '}' inattendu(e)
37: increment <- function(num, divisor)
38: }
    ^

| You almost had it, but not quite. Try again.

| N'oubliez pas de mettre les valeurs par défaut.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/remainder.R:39:0: fin d'entrée inattendue
37: increment <- function(num, divisor)
38: 
   ^

| One more time. You can do it!

| N'oubliez pas de mettre les valeurs par défaut.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/remainder.R:38:0: fin d'entrée inattendue
36: remainder <- function(num, divisor) {
37: increment <- function(num, divisor)
   ^

| Try again. Getting it right on the first try is boring anyway!

| N'oubliez pas de mettre les valeurs par défaut.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/remainder.R:38:0: fin d'entrée inattendue
36: remainder <- function(num, divisor) {
37: increment(num, divisor) 
   ^

| Not quite! Try again.

| N'oubliez pas de mettre les valeurs par défaut.

> 
> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/remainder.R:37:0: fin d'entrée inattendue
35: 
36: remainder <- function(num, divisor) {
   ^

| Almost! Try again.

| N'oubliez pas de mettre les valeurs par défaut.

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/remainder.R:37:0: fin d'entrée inattendue
35: 
36: increment <- function(num, divisor) {
   ^

| Give it another try.

| N'oubliez pas de mettre les valeurs par défaut.

> skip()

| I just sourced the following script, which demonstrates one possible solution.

Press Enter when you are ready to continue...

| All that practice is paying off!
  |====================================================================================                                                                                                                             |  40%
| Testons un petit peu le comportement de la fonction remainder. Tapez remainder(5) et observez le résultat.

> remainder(5)
[1] 1

| You got it right!
  |========================================================================================                                                                                                                         |  42%
| Observons ce qu'il s'est passé. Vous avez passé un argument à la fonction. R a décidé que cette argument était 'num', puisque 'num' est le premier argument de la fonction. La valeur par défaut pour 'divisor' est 2, R
| a donc utilisé cette valeur dans le calcul.

...
  |============================================================================================                                                                                                                     |  44%
| Observons maintenant le comportement de remainder avec 2 arguments. Tapez remainder(11, 5) et observons le résultat.

> remainder(11, 5)
[1] 1

| You are really on a roll!
  |================================================================================================                                                                                                                 |  46%
| R a utilisé le premier argument pour 'num' et le deuxième pour 'divisor'. C'est bien le comportement attendu.

...
  |====================================================================================================                                                                                                             |  48%
| Il est aussi possible de spécifier explicitement les arguments avec leur nom. Quand vous procédez ainsi, l'ordre des arguments devient sans importance. Essayez en tapant remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| Keep working like that and you'll get there!
  |========================================================================================================                                                                                                         |  50%
| Il y a une grande différence entre remainder(11, 5) et remainder(divisor = 11, num = 5).

...
  |=============================================================================================================                                                                                                    |  52%
| R peut aussi partiellement appairer valeurs et arguments. Tapez remainder(4, div = 2) et observer le résultat.

> remainder(4, div = 2)
[1] 0

| Keep up the great work!
  |=================================================================================================================                                                                                                |  54%
| Vous voulez en général faire en sorte que votre code soit lisible et compréhensible. Mélanger l'ordre des arguments en utilisant leur nom ou appairer seulement une partie des arguments n'est pas une bonne pratique.
| Faites-le avec parcimonie.

...
  |=====================================================================================================================                                                                                            |  56%
| En parlant d'arguments, vous vous demandez peut-être comment on peut découvrir tous les arguments d'une fonction. Fort heureusement, R a une fonction pour ça, args(). Utilisez args() pour connaître les arguments de
| remainder.

>  args()
Erreur dans args() : 
  l'argument "name" est manquant, avec aucune valeur par défaut
> args(remaider)
Erreur dans args(remaider) : objet 'remaider' introuvable
> args(remainder)
function (num, divisor = 2) 
NULL

| Keep up the great work!
  |=========================================================================================================================                                                                                        |  58%
| Vous ne vous en êtes peut-être pas rendu compte, mais vous venez de faire quelque chose d'intéressant. Vous avez utilisé comme argument d'une fonction une autre fonction ! Et oui, il est possible d'utiliser comme
| argument d'une fonction une autre fonction. Ecrivons un petit script pour explorer cette possibilité.

...
  |=============================================================================================================================                                                                                    |  60%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| That's not exactly what I'm looking for. Try again.

| Faites bien attention à ne pas mettre de parenthèses à la fonction que vous utilisez comme argument.

> submit()

| Sourcing your script...


| Not quite right, but keep trying.

| Faites bien attention à ne pas mettre de parenthèses à la fonction que vous utilisez comme argument.

> submit()

| Sourcing your script...


| All that practice is paying off!
  |==================================================================================================================================                                                                               |  62%
| Utilisons maintenant votre fonction evaluate() pour trouver l'écart type du vecteur c(1.4, 3.6, 7.9, 8.8).

> evaluate(median,c(1.4, 3.6, 7.9, 8.8))
[1] 5.75

| You're close...I can feel it! Try it again. Or, type info() for more options.

| La fonction écart-type dans R est la fonction sd(). N'oubliez pas que pour passer une fonction en argument il ne faut pas mettre de parenthèses à cette fonction.

> evaluate(sd,c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| Excellent job!
  |======================================================================================================================================                                                                           |  64%
| L'idée d'utiliser une fonction comme argument dans une autre fonction est un concept clé de programmation. Encore plus fort : il est possible de passer des fonctions en arguments dans une autre fonction sans avoir
| défini la fonction auparavant. Les fonctions de ce type sont appelées fonctions anonymes (ou lambda fonctions).

...
  |==========================================================================================================================================                                                                       |  66%
| Nous allons utiliser la fonction evaluate pour étudier le fonctionnement des fonctions anonymes. Comme premier argument à evaluate, nous allons écrire une petite fonction, qui tient sur une ligne. Comme second
| argument à la fonction evaluate nous allons utiliser comme argument un tout petit ensemble de données.

...
  |==============================================================================================================================================                                                                   |  68%
| Tapez la commande suivante, nous allons voir par la suite comment elle fonctionne : evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| That's a job well done!
  |==================================================================================================================================================                                                               |  70%
| Le premier argument d'evaluate est une fonction anonyme très simple qui prend comme argument 'x' et retourne 'x+1'. Nous avons dit à evaluate de passer comme argument 6 à cette fonction, le résultat est donc 7.

...
  |======================================================================================================================================================                                                           |  72%
| Essayez d'utiliser evaluate() avec une fonction anonyme afin qu'elle retourne le premier élément d'un vecteur. Votre fonction anonyme devrait prendre un seul argument, qui devrait être la variable x. Le vecteur que
| vous devez utiliser pour tester cette fonction doit être le vecteur c(8, 4, 0).

> evaluate(x,c(8, 4, 0))
Erreur dans func(dat) : impossible de trouver la fonction "func"
> evaluate(func(dat),c(8, 4, 0))
Erreur dans func(dat) : impossible de trouver la fonction "func"
> evaluate(c(8, 4, 0))
Erreur dans func(dat) : impossible de trouver la fonction "func"
> func(dat)
Erreur dans func(dat) : impossible de trouver la fonction "func"
> skip()

| Entering the following correct answer for you...

> evaluate(function(x){x[1]}, c(8, 4, 0))
[1] 8

| That's the answer I was looking for.
  |===========================================================================================================================================================                                                      |  74%
| Utilisez maintenant la fonction evaluate() et une fonction anonyme afin de retourner le dernier élément d'un vecteur. Votre fonction anonyme ne doit avoir qu'un seul argument qui sera x. Le vecteur que vous devez
| utiliser pour tester cette fonction doit être le vecteur c(8, 4, 0).

> evaluate(function(x), c(8, 4, 0))
Erreur : ',' inattendu(e) dans "evaluate(function(x),"
> evaluate(function(x){x[3]}, c(8, 4, 0))
[1] 0

| Give it another try. Or, type info() for more options.

| Rappelez vous comment on fait appel à un élément particulier dans un vecteur à l'aide de son index. Votre fonction anonyme ne doit avec qu'un seul argument et le nom de cette argument doit être x. La fonction
| length() peut être utile dans votre fonctio anonyme.

> evaluate(function(x),lenght(c(8, 4, 0))
Erreur : ',' inattendu(e) dans "evaluate(function(x),"
> evaluate(function(x){x[3]},lenght(c(8, 4, 0))
+ 
+ evaluate(function(x){x[3]}lenght(c(8, 4, 0))
Erreur : symbole inattendu dans :
"
evaluate"
> evaluate(lenght(c(8, 4, 0))
+ function(x)
Erreur : 'function' inattendu(e) dans :
"evaluate(lenght(c(8, 4, 0))
function"
> evaluate(function(x){x[lenght(x)]}, c(8, 4, 0))
Erreur dans lenght(x) : impossible de trouver la fonction "lenght"
> evaluate(function(x){x[length(x)]}, c(8, 4, 0))
[1] 0

| All that hard work is paying off!
  |===============================================================================================================================================================                                                  |  76%
| Jusqu'à la fin de cette leçon nous allons utiliser la fonction paste() fréquemment. Tapez ?paste pour lire la documentation de cette fonction et comprendre son fonctionnement.

> ?paste
démarrage du serveur d'aide httpd ... fini

| You got it right!
  |===================================================================================================================================================================                                              |  78%
| Afin de comprendre comment paste() fonctionne, essayez de taper paste("La", "programmation", "c'est", "facile !").

> paste("La", "programmation", "c'est", "facile !")
[1] "La programmation c'est facile !"

| You are really on a roll!
  |=======================================================================================================================================================================                                          |  80%
| Ecrivons maintenant notre propre version de paste().

...
  |===========================================================================================================================================================================                                      |  82%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...

Error in source(e$script_temp_path, encoding = "UTF-8") : 
  /var/folders/fl/y3sd58wj0rg26t0dnpjdtdpw0000gp/T//Rtmp4wlyyw/telegram.R:35:16: symbole inattendu
34: telegram <- function(...){
35:   paste("START"...
                   ^

| You are amazing!
  |================================================================================================================================================================================                                 |  84%
| Essayons maintenant votre nouvelle fonction telegram(). Utilisez votre fonction telegram() avec n'importe quels arguments.

> telegram("bonne")
[1] "START bonne STOP"

| That's a job well done!
  |====================================================================================================================================================================================                             |  86%
| Avant de continuer, nous devons faire un petit détour par les listes. Nous avons déjà vu les listes dans la leçon sur les types (mot clé `list`). Une capacité que nous n'avons pas exploré ni exploité des listes
| jusqu'à présent et le fait qu'on puisse nommer les éléments des listes. Par exemple, on peut créer une liste contenant un vecteur poids et un vecteur tailles. tailles doit être un vecteur contenant les tailles 154,
| 175 et 165 (dant cet ordre). poids doit être un vecteur contenant les poids 55, 80 et 65 (dant cet ordre). On veut mettre ces deux vecteurs dans une liste. On tapera alors list(tailles = c(154, 175, 165), poids =
| c(55, 80, 65)). On souhaite assigner cette list à ma_liste.

> list(tailles = c(154, 175, 165), poids = c(55, 80, 65))
$tailles
[1] 154 175 165

$poids
[1] 55 80 65


| Not quite right, but keep trying. Or, type info() for more options.

| Tapez : ma_liste <- list(tailles = c(154, 175, 165), poids = c(55, 80, 65))

>  ma_liste <- list(tailles = c(154, 175, 165), poids = c(55, 80, 65))

| Your dedication is inspiring!
  |========================================================================================================================================================================================                         |  88%
| Observons maintenant ma_liste.

> ma_liste
$tailles
[1] 154 175 165

$poids
[1] 55 80 65


| All that practice is paying off!
  |============================================================================================================================================================================================                     |  90%
| On peut accéder à un élément nommé d'une liste à l'aide de la syntaxe list$nom ou bien à l'aide de list[["nom"]], tout comme on a pu le faire pour des colonnes d'un data.frame. Essayez d'accéder à la colonne tailles
| de ma_list.

> list[["ma_list"]]
Erreur dans list[["ma_list"]] : objet de type 'builtin' non indiçable
> data.frame
function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, 
    fix.empty.names = TRUE, stringsAsFactors = FALSE) 
{
    data.row.names <- if (check.rows && is.null(row.names)) 
        function(current, new, i) {
            if (is.character(current)) 
                new <- as.character(new)
            if (is.character(new)) 
                current <- as.character(current)
            if (anyDuplicated(new)) 
                return(current)
            if (is.null(current)) 
                return(new)
            if (all(current == new) || all(current == "")) 
                return(new)
            stop(gettextf("mismatch of row names in arguments of 'data.frame', item %d", 
                i), domain = NA)
        }
    else function(current, new, i) {
        if (is.null(current)) {
            if (anyDuplicated(new)) {
                warning(gettextf("some row.names duplicated: %s --> row.names NOT used", 
                  paste(which(duplicated(new)), collapse = ",")), 
                  domain = NA)
                current
            }
            else new
        }
        else current
    }
    object <- as.list(substitute(list(...)))[-1L]
    mirn <- missing(row.names)
    mrn <- is.null(row.names)
    x <- list(...)
    n <- length(x)
    if (n < 1L) {
        if (!mrn) {
            if (is.object(row.names) || !is.integer(row.names)) 
                row.names <- as.character(row.names)
            if (anyNA(row.names)) 
                stop("row names contain missing values")
            if (anyDuplicated(row.names)) 
                stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), 
                  collapse = ", ")), domain = NA)
        }
        else row.names <- integer()
        return(structure(list(), names = character(), row.names = row.names, 
            class = "data.frame"))
    }
    vnames <- names(x)
    if (length(vnames) != n) 
        vnames <- character(n)
    no.vn <- !nzchar(vnames)
    vlist <- vnames <- as.list(vnames)
    nrows <- ncols <- integer(n)
    for (i in seq_len(n)) {
        xi <- if (is.character(x[[i]]) || is.list(x[[i]])) 
            as.data.frame(x[[i]], optional = TRUE, stringsAsFactors = stringsAsFactors)
        else as.data.frame(x[[i]], optional = TRUE)
        nrows[i] <- .row_names_info(xi)
        ncols[i] <- length(xi)
        namesi <- names(xi)
        if (ncols[i] > 1L) {
            if (length(namesi) == 0L) 
                namesi <- seq_len(ncols[i])
            vnames[[i]] <- if (no.vn[i]) 
                namesi
            else paste(vnames[[i]], namesi, sep = ".")
        }
        else if (length(namesi)) {
            vnames[[i]] <- namesi
        }
        else if (fix.empty.names && no.vn[[i]]) {
            tmpname <- deparse(object[[i]], nlines = 1L)[1L]
            if (startsWith(tmpname, "I(") && endsWith(tmpname, 
                ")")) {
                ntmpn <- nchar(tmpname, "c")
                tmpname <- substr(tmpname, 3L, ntmpn - 1L)
            }
            vnames[[i]] <- tmpname
        }
        if (mirn && nrows[i] > 0L) {
            rowsi <- attr(xi, "row.names")
            if (any(nzchar(rowsi))) 
                row.names <- data.row.names(row.names, rowsi, 
                  i)
        }
        nrows[i] <- abs(nrows[i])
        vlist[[i]] <- xi
    }
    nr <- max(nrows)
    for (i in seq_len(n)[nrows < nr]) {
        xi <- vlist[[i]]
        if (nrows[i] > 0L && (nr%%nrows[i] == 0L)) {
            xi <- unclass(xi)
            fixed <- TRUE
            for (j in seq_along(xi)) {
                xi1 <- xi[[j]]
                if (is.vector(xi1) || is.factor(xi1)) 
                  xi[[j]] <- rep(xi1, length.out = nr)
                else if (is.character(xi1) && inherits(xi1, "AsIs")) 
                  xi[[j]] <- structure(rep(xi1, length.out = nr), 
                    class = class(xi1))
                else if (inherits(xi1, "Date") || inherits(xi1, 
                  "POSIXct")) 
                  xi[[j]] <- rep(xi1, length.out = nr)
                else {
                  fixed <- FALSE
                  break
                }
            }
            if (fixed) {
                vlist[[i]] <- xi
                next
            }
        }
        stop(gettextf("arguments imply differing number of rows: %s", 
            paste(unique(nrows), collapse = ", ")), domain = NA)
    }
    value <- unlist(vlist, recursive = FALSE, use.names = FALSE)
    vnames <- as.character(unlist(vnames[ncols > 0L]))
    if (fix.empty.names && any(noname <- !nzchar(vnames))) 
        vnames[noname] <- paste0("Var.", seq_along(vnames))[noname]
    if (check.names) {
        if (fix.empty.names) 
            vnames <- make.names(vnames, unique = TRUE)
        else {
            nz <- nzchar(vnames)
            vnames[nz] <- make.names(vnames[nz], unique = TRUE)
        }
    }
    names(value) <- vnames
    if (!mrn) {
        if (length(row.names) == 1L && nr != 1L) {
            if (is.character(row.names)) 
                row.names <- match(row.names, vnames, 0L)
            if (length(row.names) != 1L || row.names < 1L || 
                row.names > length(vnames)) 
                stop("'row.names' should specify one of the variables")
            i <- row.names
            row.names <- value[[i]]
            value <- value[-i]
        }
        else if (!is.null(row.names) && length(row.names) != 
            nr) 
            stop("row names supplied are of the wrong length")
    }
    else if (!is.null(row.names) && length(row.names) != nr) {
        warning("row names were found from a short variable and have been discarded")
        row.names <- NULL
    }
    class(value) <- "data.frame"
    if (is.null(row.names)) 
        attr(value, "row.names") <- .set_row_names(nr)
    else {
        if (is.object(row.names) || !is.integer(row.names)) 
            row.names <- as.character(row.names)
        if (anyNA(row.names)) 
            stop("row names contain missing values")
        if (anyDuplicated(row.names)) 
            stop(gettextf("duplicate row.names: %s", paste(unique(row.names[duplicated(row.names)]), 
                collapse = ", ")), domain = NA)
        row.names(value) <- row.names
    }
    value
}
<bytecode: 0x7f9ab8e70070>
<environment: namespace:base>

| Not exactly. Give it another go. Or, type info() for more options.

| Faites bien attention à la syntaxe et demandez-vous comment s'appelle votre liste et quel est le nom de l'élément que vous souhaitez voir.

> data.frame.ma_list
Erreur : objet 'data.frame.ma_list' introuvable
> data.ma_list
Erreur : objet 'data.ma_list' introuvable
> ma_list$tailles
Erreur : objet 'ma_list' introuvable
> list$tailles
Erreur dans list$tailles : objet de type 'builtin' non indiçable
> list$ma_list
Erreur dans list$ma_list : objet de type 'builtin' non indiçable
> list[["tailles"]]
Erreur dans list[["tailles"]] : objet de type 'builtin' non indiçable
> data.frame.tailles
Erreur : objet 'data.frame.tailles' introuvable
> data.taille
Erreur : objet 'data.taille' introuvable
> data.tailles
Erreur : objet 'data.tailles' introuvable
> data.frame(tailles)
  tailles
1     156
2     164
3     197
4     147
5     173

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Faites bien attention à la syntaxe et demandez-vous comment s'appelle votre liste et quel est le nom de l'élément que vous souhaitez voir.

> data.frame(ma_list,tailles)
Erreur dans data.frame(ma_list, tailles) : objet 'ma_list' introuvable
> my_list[["data.frame(tailles)"]]
Erreur : objet 'my_list' introuvable
> list[["data.frame(tailles)"]]
Erreur dans list[["data.frame(tailles)"]] : 
  objet de type 'builtin' non indiçable
> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> skip()

| Entering the following correct answer for you...

> ma_liste$tailles
[1] 154 175 165

| Great job!
  |================================================================================================================================================================================================                 |  92%
| Fin de la parenthèse sur les listes. Nous allons avoir besoin des listes pour le prochain exercices que nous utilisons. En effet, l'argument ... est considéré comme une liste par R.

...
  |====================================================================================================================================================================================================             |  94%
| Sauvegardez bien votre script avant de taper submit().

> submit()

| Sourcing your script...


| Not quite! Try again.

| Votre fonction doit contenir trois parties. Une capture des ... dans une liste. Le découpage des arguments des ... et l'assignation à une variable. Le passage des variables dans la fonction paste().

> submit()

| Sourcing your script...


| You are doing so well!
  |=========================================================================================================================================================================================================        |  96%
| Utilisons maintenant votre fonction manif. Pensez bien à nommer les arguments place, adjective et noun pour que votre fonction accomplisse son travail.

> manif("place","adjective","noun")
[1] "Nouvelles de  aujourd'hui, des étudiant.e.s  ont fait grève contre les nouveaux  installés dans l'université."

| You are amazing!
  |=============================================================================================================================================================================================================    |  98%
| Nous avons fini cette leçon. Vous avez maintenant un des concepts les plus important de R et du monde de la programmation, les fonctions.

...
  |=================================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui envoyer
| le fichier 'Scripts_et_fonctions.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Give it another try.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 2

| Keep trying!

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 