
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

[R.app GUI 1.79 (8095) x86_64-apple-darwin17.0]

[Espace de Travail restauré depuis /Users/imenetalbi/.RData]
[Historique recherché depuis /Users/imenetalbi/.Rapp.history]

> install.packages('swirl')
--- SVP sélectionnez un miroir CRAN pour cette session ---
essai de l'URL 'https://cran.irsn.fr/bin/macosx/contrib/4.2/swirl_2.4.5.tgz'
Content type 'application/x-gzip' length 348108 bytes (339 KB)
==================================================
downloaded 339 KB


Les packages binaires téléchargés sont dans
	/var/folders/lw/c_gmshvs7s52n371l5ptn9_m0000gn/T//RtmpSKQNeG/downloaded_packages
> library(swirl)

| Hello! Je vois que tu as enregistré certaines variables dans ton espace de
| travail. Pour que tout se passe bien, je te recommande de faire le ménage
| avant de lancer Swirl.

| Tape ls() pour voir la liste de tes variables dans ton espace de travail.
| Ensuite, tape rm(list=ls()) pour nettoyer ton espace de travail.

| Tape swirl() quand tu es prêt(e) à te lancer.

> install_course_github("EliasBcd", "InitiationR")
Downloading: 84 kB      
> swirl()

| Bienvenue sur Swirl ! Connecte-toi. Si ce n'est pas ta première connexion, indique ton nom utilisé précédemment. Si tu dois encore choisir ton nom, fais preuve d'un peu d'originalité !

Comment dois-je t'appeler ? Adam

| Merci, Adam. Quelques instructions de base avant d'attaquer la première leçon. Tout d'abord, si tu vois s'afficher '...', cela veut dire que tu dois appuyer sur Entrée quand tu as fini de lire et es prêt(e) à
| continuer.

...  <-- That's your cue to press Enter to continue

| Et quand tu vois 'Réponse:', le prompt R (>), ou si tu es invité(e) à sélectionner une option, c'est à toi de taper ta réponse et d'appuyer sur Entrée pour continuer.

Select 1, 2, or 3 and press Enter 

1: Continuer.
2: Avancer.
3: C'est parti !

Sélection : 1

| You can exit swirl and return to the R prompt (>) at any time by pressing the Esc key. If you are already at the prompt, type bye() to exit and save your progress. When you exit properly, you'll see a short
| message letting you know you've done so.

| Quand tu es arrivé(e) au prompt R (>):
| -- Tape skip() pour sauter la question.
| -- Tape play() pour expérimenter et jouer avec R; Swirl en fera abstraction...
| -- JUSQU'A ce que tu tapes nxt() pour regagner l'attention de Swirl.
| -- Tape bye() pour quitter Swirl. Ta progression sera sauvegardée.
| -- Tape main() pour retourner au menu principal de Swirl.
| -- Tape info() pour montrer les options une nouvelle fois.

| C'est parti !

...

| Choisis un cours ou tape 0 pour quitter Swirl.

1: InitiationR
2: Montre-moi le répertoire des cours Swirl !

Sélection : 1

| Choisis une leçon ou tape 0 pour retourner au menu principal.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   


Sélection : 4

| Attempting to load lesson dependencies...

| Le paquet ‘base64enc’ a été chargé correctement !
  |                                                                                                                                                                                                           |   0%

| Nous verrons dans cette leçon les vecteurs plus en détails.

...
  |=======                                                                                                                                                                                                    |   3%
| Nous avons vu que nous pouvons créer un vecteur à l'aide de la commande c(). Reprenez le vecteur contenant les tailles précédentes, tapez c(156, 164, 197). Essayez et stockez le résultat dans l'objet tailles.

> c(156, 164, 197)
[1] 156 164 197

| Ce n'est pas tout à fait ce que je cherche. Essaie encore. ou tape info() pour plus d'options.

| Tapez tailles <- c(156, 164, 197) et appuyez sur entrée. Cela assigne le vecteur (156, 164, 197) au nouvel objet tailles.
| Les espaces après la virgule ne sont pas nécessaire mais rendent le code plus lisible.

> tailles <- c(156, 164, 197)

| Tu es extraordinaire !
  |==============                                                                                                                                                                                             |   7%
| Tapez tailles pour voir son contenu. Remarquez qu'il y n'y a pas de virgules qui séparent les valeurs dans l'affichage.

> tailles
[1] 156 164 197

| That's the answer I was looking for.
  |====================                                                                                                                                                                                       |  10%
| On peut combiner les vecteurs pour faire un nouveau vecteur. Créez un vecteur qui combine tailles, 185 et tailles encore,
| dans cet ordre. N'assignez pas le vecteur à un nouvel objet, afin qu'on puisse voir le résultat immédiatement.

> c(taillles,185,tailles)
Erreur : objet 'taillles' introuvable
> c(tailles,185,tailles)
[1] 156 164 197 185 156 164 197

| That's the answer I was looking for.
  |===========================                                                                                                                                                                                |  13%
| Les vecteurs numériques peuvent aussi servir dans des opérations. On peut par exemple convertir les tailles en mètres et
| assigner le résultat à l'objet tailles_m.

> tailles_m<-tailles/100

| Excellent work!
  |==================================                                                                                                                                                                         |  17%
| Avant de voir l'objet tailles_m, que pensez-vous qu'il contient ?

1: un vecteur de longueur 3
2: un nombre (= un vecteur de longueur 1)
3: un vecteur de longueur 0 (= un vecteur vide)

Sélection : 2

| Try again. Getting it right on the first try is boring anyway!

| R procèce aux opérations sur les vecteurs éléments par éléments.

1: un vecteur de longueur 3
2: un nombre (= un vecteur de longueur 1)
3: un vecteur de longueur 0 (= un vecteur vide)

Sélection : 3

| Ce n'est pas tout à fait ce que je cherche. Essaie encore.

| R procèce aux opérations sur les vecteurs éléments par éléments.

1: un vecteur de longueur 3
2: un nombre (= un vecteur de longueur 1)
3: un vecteur de longueur 0 (= un vecteur vide)

Sélection : 1

| All that hard work is paying off!
  |=========================================                                                                                                                                                                  |  20%
| Affichez maintenant le résultat.

> tailles_m
[1] 1.56 1.64 1.97

| All that hard work is paying off!
  |===============================================                                                                                                                                                            |  23%
| Comment vous l'avez probablement deviné, R a d'abord divisé `tailles` par 100, puis a stocje le résultat dans
| `tailles_m`. On obtient ainsi un vecteur de même longueur que le vecteur d'origine `tailles`.

...
  |======================================================                                                                                                                                                     |  27%
| On cherche maintenant à calculer les IMC correspondant aux tailles. Commençons par créer un nouveau vecteur poids,
| contenant les valeurs 55, 65 et 78 (dans cet ordre)

> c(55,65,78)
[1] 55 65 78

| Pas exactement. Retente ta chance. ou tape info() pour plus d'options.

| Rappelez-vous comment on a créé des vecteurs plus tôt.

> poids <- c(55,65,78)

| Excellent travail !
  |=============================================================                                                                                                                                              |  30%
| Calculons maintenant l'imc de chacun. Créez une nouvelle variable imc qui prend les valeurs des poids divisés par taille
| au carré. N'oubliez pas que la taille doit être en mètre !

> imc <- poids/tailles_m^2

| Keep working like that and you'll get there!
  |====================================================================                                                                                                                                       |  33%
| Quelle affirmation est vraie ?

1: Le premier élément d'`imc` est égal au premier élément de `poids` divisé par le carré du premier élément de `tailles_m`, etc.
2: `imc` est un nombre unique
3: `imc` n'est pas défini

Sélection : 1

| Excellent work!
  |==========================================================================                                                                                                                                 |  37%
| Regardons le contenu d'`imc`.

> imc
[1] 22.60026 24.16716 20.09843

| Excellent travail !
  |=================================================================================                                                                                                                          |  40%
| Un vecteur ne contient pas forcément que des nombres. Il peut aussi contenir des booléens ou des chaînes de caractères.
| Essayez de créer un vecteurs chiens contenant les race suivantes, Doberman, Chihuahua et Husky (dans cet ordre).
| Rappelez-vous comment on peut entrer des chaînes de caractères.

> chiens<-c("Doberman","Chihuahua","Husky" )

| Quelle maîtrise !
  |========================================================================================                                                                                                                   |  43%
| Rappelez-vous néanmoins que les valeurs contenues dans un vecteur sont forcément du même type. Si vous entrez par exemple
| des nombres et des chaînes de caractères dans un vecteur, R convertira les nombres en chaînes de caractère.

...
  |===============================================================================================                                                                                                            |  47%
| Quand R a deux vecteurs de même longeur, R effectue les opérations spécifiée élément par élément. Dans le cas ou un des
| vecteurs est plus court que les autres, R 'recycle' le vecteur le plus court jusqu'à ce qu'il atteigne la longueur du
| vecteur le plus long.

...
  |======================================================================================================                                                                                                     |  50%
| Quand on a calculé `tailles / 100` plus tôt, tailles est un vecteur de longueur 3, et techniquement 100 est un vecteur de
| longueur 1. Pour effectuer le calcul, R 'recycle' 100 pour en faire un vecteur de 100. En clair, l'opération réellement
| effectuée est `tailles / c(100, 100, 100)`.

...
  |============================================================================================================                                                                                               |  53%
| Voici un exemple de 'recyclage', plus parlant. Essayez d'ajouter `c(1, 2, 3, 4)` et `c(0, 10)`.

> tailles<-c(1,2,3,4)

| Ce n'est pas tout à fait ce que je cherche. Essaie encore. ou tape info() pour plus d'options.

| Tapez c(1, 2, 3, 4) + c(0, 10) dans la console. N'essayez pas de sauvegarder le résultat dans un objet.

> c(1, 2, 3, 4) + c(0, 10)
[1]  1 12  3 14

| Excellent travail !
  |===================================================================================================================                                                                                        |  57%
| Si la longueur du vecteur le plus long n'est pas un multiple de la longueur du vecteur le plus court, R continuera à
| recycler les valeur, mais vous préviendra que quelque chose de potentiellement étrange se déroule.

...
  |==========================================================================================================================                                                                                 |  60%
| Essayez c(1, 2, 3, 4) + c(0, 10, 100) par exemple.

> c(1, 2, 3, 4) + c(0, 10, 100)
[1]   1  12 103   4
Message d'avis :
Dans c(1, 2, 3, 4) + c(0, 10, 100) :
  la taille d'un objet plus long n'est pas multiple de la taille d'un objet plus court

| Keep working like that and you'll get there!
  |=================================================================================================================================                                                                          |  63%
| Remarquez le Warning envoye par R. Il vout signale que quelque chose de quelque peu inattendu est arrivé (mais il fait le
| calcul). Il y a de nombreuses autres manières de construire des vecteurs, en particulier des vecteurs de numériques. Nous
| les verrons en temps voulu.

...
  |=======================================================================================================================================                                                                    |  67%
| Pour extraire un sous-vecteur de R, il faut utiliser des crochets `[]`. Si vous souhaitez accéder au deuxième élément du
| vecteur tailles, il faut taper `tailles[2]`.

> tailles[2]
[1] 164

| Tu es extraordinaire !
  |==============================================================================================================================================                                                             |  70%
| Il est aussi possible d'exclure un sous-ensemble du vecteur en mettant un moins devant le ou les indices que nous
| souhaitons exclure. Par exemple, pour exclure le deuxième élément de `tailles`, il faut taper `tailles[-2]`. Essayez.

> tailles[-2]
[1] 156 197

| Bravo!
  |=====================================================================================================================================================                                                      |  73%
| Il est aussi possible d'obtenir un sous-ensemble du vecteur en utilisant un vecteur d'indices plutôt qu'une valeur
| unique. Par exemple, pour obtenir le premier et le troisième élément de poids, il faut taper `poids[c(1, 3)]`. Essayez.

> poids[c(1, 3)]
[1] 55 78

| Excellent work!
  |============================================================================================================================================================                                               |  77%
| Le fonctionnement est le même pour l'exclusion de sous-ensembles d'un vecteur.

...
  |==================================================================================================================================================================                                         |  80%
| Une dernière façon d'indexer des sous-ensembles est d'utiliser un vecteur de valeurs logiques. Essayez `tailles[c(TRUE,
| TRUE, FALSE)]`.

> ailles[c(TRUE, TRUE, FALSE)]
Erreur : objet 'ailles' introuvable
> tailles[c(TRUE, TRUE, FALSE)]
[1] 156 164

| Excellent travail !
  |=========================================================================================================================================================================                                  |  83%
| Cela peut paraître inutile au premier abord, mais est en fait très utile pour extraire d'un vecteur des valeurs
| respectant une condition logique. Si on souhaite obtenir les seulement les poids inférieurs à 70kg par exemple, on tapera
| la commande `poids[poids < 70]`.

> poids[poids < 70]
[1] 55 65

| Excellent travail !
  |================================================================================================================================================================================                           |  87%
| Avant de finir la leçon, je vais vous apprendre quelques techniques pour gagner un peu de temps. Tout à l'heure, vous
| avez calculé tailles / 100. Imaginons que vous vous soyez trompé et que vous avez divisé par 1000 plutôt que 100. Vous
| pouvez retaper toute l'expression, ou bien...

...
  |=======================================================================================================================================================================================                    |  90%
| Dans beaucoup d'environnement de programmation, la flèche vers le haut vous permet de visualiser les commandes
| précédentes. Appuyez sur la flèche haut de votre clavier jusqu'à atteindre la commande tailles_m <- tailles / 100.
| Changez 100 en 1000 et appuyez sur entrée. Si la flèche vers le haut ne marche pas chez vous, tapez juste l'expression en
| entier.

> tailles_m <- tailles / 1000

| C'est la bonne réponse !
  |=============================================================================================================================================================================================              |  93%
| Enfin, imaginons que vous voulez afficher le contenu d'un objet que vous avez créé auparavant, mais que vous ne vous
| souvenez plus du nom exact, taillesm ou taillesM ou tailles_m. Vous pouvez essayer les deux et chercher celle qui marche,
| ou...

...
  |====================================================================================================================================================================================================       |  97%
| Vous pouvez taper les deux lettres du nom de l'objet et appuyer sur la touche Tab (potentiellement plusieurs fois). La
| plupart des environnements de programmation vous afficheront une liste des objets que vous avez créé qui commence par
| 'tail'. Cela s'appelle l'auto-complétion et c'est très pratique. Essayez.

> tail
function (x, ...) 
UseMethod("tail")
<bytecode: 0x7fdc6888a900>
<environment: namespace:utils>

| Pas tout à fait ! Essaie à nouveau. ou tape info() pour plus d'options.

| Si votre environnement de programmation ne vous permet pas d'utiliser l'auto-complétion, tapez simplement tailles_m et
| appuyez sur entrée pour continuer.

> tailles_m
[1] 0.156 0.164 0.197

| Tu assures !
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de
| l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui envoyer le fichier 'Vecteurs.txt'
| qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Continue ! Tu trouveras !

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 1

| Bravo!

| Tu es arrivé(e) au bout de cette leçon! Retour au menu principal...

| Choisis un cours ou tape 0 pour quitter Swirl.

1: InitiationR
2: Montre-moi le répertoire des cours Swirl !

Sélection : 1

| Choisis une leçon ou tape 0 pour retourner au menu principal.

 1: Manipulations simples           2: Assignations et objets          3: Types                        
 4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                   
10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   


Sélection : 5

| Attempting to load lesson dependencies...

| Le paquet ‘base64enc’ a été chargé correctement !
  |                                                                                                                  |   0%

| Dans cette leçon, nous etudierons comment examiner votre espace de travail local dans R et le lien entre cet espace de
| travail et les fichiers sur votre ordinateur.

...
  |=====                                                                                                             |   5%
| Chaque système d'exploitation a sa propre convention pour explorer les fichiers, les résultats des commandes dans ce
| cours pourront varier suivant votre système d'exploitation.

...
  |==========                                                                                                        |   9%
| R utilise néanmoins le même ensemble de commande quelque soit le système d'exploitation. Votre code fonctionnera
| normalement de la même manière partout. Essayons !

...
  |================                                                                                                  |  14%
| Pour déterminer le dossier dans lequel R travaille actuellement, on utilise la commande getwd() (get working directory).
| Essayez !

> 
> getwd()
[1] "/Users/imenetalbi"

| That's the answer I was looking for.
  |=====================                                                                                             |  18%
| Pour lister tous les objets actuellement dans votre espace de travail il faut utiliser la commande ls().

> ls()
 [1] "anc"       "anc.doc"   "anc.dos"   "chiens"    "data"      "imc"       "l"         "ma_seq"    "my_na"     "poids"    
[11] "taille"    "taille1"   "taille2"   "taille3"   "tailles"   "tailles_m" "v"         "x"         "X"         "y"        
[21] "z"        

| C'est du bon boulot !
  |==========================                                                                                        |  23%
| Un certain nombre de commande R ont les mêmes noms que leurs commandes équivalentes sous Linux ou Mac. Ces deux systèmes
| d'exploitations sont issus d'un système d'exploitation appelé Unix. Windows n'en est pas issu, les commandes peuvent donc
| différer.

...
  |===============================                                                                                   |  27%
| Assignez 9 à x, comme vous l'avez appris dans la leçon sur les assignations.

> x->9
Erreur dans 9 <- x : membre gauche de l'assignation (do_set) incorrect
> 9<-x
Erreur dans 9 <- x : membre gauche de l'assignation (do_set) incorrect
> 9->x

| Perseverance, that's the answer.
  |====================================                                                                              |  32%
| Observez maintenant les objets dans votre espace de travail avec la commande ls().

> 
> ls()
 [1] "anc"       "anc.doc"   "anc.dos"   "chiens"    "data"      "imc"       "l"         "ma_seq"    "my_na"     "poids"    
[11] "taille"    "taille1"   "taille2"   "taille3"   "tailles"   "tailles_m" "v"         "x"         "X"         "y"        
[21] "z"        

| Excellent travail !
  |=========================================                                                                         |  36%
| Vous pouvez afficher tous les fichiers dans votre dossier de travail en utilisant les commandes list.files() ou dir().

> dir()
 [1] "Applications"                      "Desktop"                           "Documents"                        
 [4] "Downloads"                         "Fichiers_et_espace_de_travail.txt" "iCloud Drive (archive)"           
 [7] "Library"                           "Logique.txt"                       "Movies"                           
[10] "Music"                             "Pictures"                          "Public"                           
[13] "testdos"                           "Valeurs_manquantes.txt"            "Vecteurs_numeriques.txt"          
[16] "Vecteurs.txt"                     

| Quel talent !
  |===============================================                                                                   |  41%
| Une bonne pratique d'apprentissage. Pendant cette leçon, vous devriez examiner le fichier d'aide de chaque nouvelle
| commande à l'aide de la commande ?. Regardez l'aide de la commande list.files ou dir.

> dir
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
.Internal(list.files(path, pattern, all.files, full.names, recursive, 
    ignore.case, include.dirs, no..))
<bytecode: 0x7fdc2f8513c0>
<environment: namespace:base>

| Not quite, but you're learning! Try again. ou tape info() pour plus d'options.

| Tapez ?list.files pour voir l'aide. N'oubliez pas qu'il ne faut pas mettre de parenthèses.

> list.files
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
.Internal(list.files(path, pattern, all.files, full.names, recursive, 
    ignore.case, include.dirs, no..))
<bytecode: 0x7fdc68a5d340>
<environment: namespace:base>

| Ce n'est pas tout à fait ce que je cherche. Essaie encore. ou tape info() pour plus d'options.

| Tapez ?list.files pour voir l'aide. N'oubliez pas qu'il ne faut pas mettre de parenthèses.

> info()

| Quand tu es arrivé(e) au prompt R (>):
| -- Tape skip() pour sauter la question.
| -- Tape play() pour expérimenter et jouer avec R; Swirl en fera abstraction...
| -- JUSQU'A ce que tu tapes nxt() pour regagner l'attention de Swirl.
| -- Tape bye() pour quitter Swirl. Ta progression sera sauvegardée.
| -- Tape main() pour retourner au menu principal de Swirl.
| -- Tape info() pour montrer les options une nouvelle fois.

> ?list.files
démarrage du serveur d'aide httpd ... fini

| Excellent travail !
  |====================================================                                                              |  45%
| Une des parties les plus importante de l'aide est la section See Also. Lisez là pour la commande list.files. Certaines de
| ces commandes pourront être utilisées par la suite.

...
  |=========================================================                                                         |  50%
| La commande args() utilisée sur une autre commande permet de connaître les arguments qu'elle prend. C'est parfois très
| pratique.

...
  |==============================================================                                                    |  55%
| Utilisez la commande args() pour déterminer les arguments utilisé par la commande list.files().

> args(list.files)
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
NULL

| Excellent work!
  |===================================================================                                               |  59%
| Assignez la valeur du dossier de travail actuel à un objet appelé "anc.dos".

> 5->anc.doc

| Tente encore une fois. ou tape info() pour plus d'options.

| Tapez anc.dos <- getwd() pour assignez la valeur de l'espace de travail actuel à l'objet "anc.dos".

> anc<-getwd()

| Pas tout à fait ! Essaie à nouveau. ou tape info() pour plus d'options.

| Tapez anc.dos <- getwd() pour assignez la valeur de l'espace de travail actuel à l'objet "anc.dos".

> anc.dos<-getwd()

| Tu es au top !
  |=========================================================================                                         |  64%
| Nous reviendrons vers anc.dos plus tard. Beaucoup de commandes ont la propriété pratique d'envoyer comme résultat la
| réponse à la question qu'elle pose.

...
  |==============================================================================                                    |  68%
| Utilisez dir.create() pour créer un dossier de test appelé "testdos" dans le dossier de travail actuel.

> dir.create("testdos")
Message d'avis :
Dans dir.create("testdos") : 'testdos' existe déjà

| Excellent work!
  |===================================================================================                               |  73%
| Nous allons maintenant déplacer notre dossier de travail courant dans le dossier "testdos"

...
  |========================================================================================                          |  77%
| Pour ce faire, on utilise la commande setwd() sur le dossier "testdos".

> setwd("testdos")

| That's the answer I was looking for.
  |=============================================================================================                     |  82%
| En général, vous voudrez avoir votre dossier de travail courant dans un endroit raisonnable, par exemple spécifique au
| projet sur lequel vous êtes en train de travailler.

...
  |==================================================================================================                |  86%
| Revenez à votre espace de travail d'origine and utilisant la commande setwd().

> setwd(anc.dos)

| Quelle maîtrise !
  |========================================================================================================          |  91%
| Vous pouvez maintenant supprimer le dossier "testdos" et tout son contenu.

...
  |=============================================================================================================     |  95%
| Dans cette leçon, vous avez appris à examiner ce que contiennent votre espace de travail et votre dossier de travail.
| Vous avez aussi commencé à manipuler les fichiers et dossiers depuis R.

...
  |==================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de
| l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui envoyer le fichier
| 'Fichiers_et_espace_de_travail.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Pas tout à fait, mais continue à chercher !

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 2

| Excellent travail !

| Tu es arrivé(e) au bout de cette leçon! Retour au menu principal...

| Choisis un cours ou tape 0 pour quitter Swirl.

1: InitiationR
2: Montre-moi le répertoire des cours Swirl !

Sélection : 1

| Choisis une leçon ou tape 0 pour retourner au menu principal.

 1: Manipulations simples           2: Assignations et objets          3: Types                        
 4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                   
10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   


Sélection : 6

| Attempting to load lesson dependencies...

| Le paquet ‘base64enc’ a été chargé correctement !
  |                                                                                                                  |   0%

| Cette leçon introduit les opérateurs et opérations logiques dans R.

...
  |====                                                                                                              |   3%
| Comme nous l'avons déjà vu, il y a deux valeurs logiques dans R, aussi appelé valeurs booléennes, TRUE et FALSE. Dans R,
| il est possible de créer des expressions logiques dont le résultat sera TRUE ou FALSE.

...
  |=======                                                                                                           |   6%
| La création d'expressions logiques nécessite des opérateurs logiques. Nous avons déjà vu les opérateurs arithmétiques tel
| que `+`, `-`, `*` et `/`. Le premier opérateur logique à connaître est l'égalité, représenté par deux signes égalités
| `==`. Essayez d'utiliser cet opérateur pour trouver si TRUE et TRUE sont égaux.

> TRUE == TRUE
[1] TRUE

| Tu es au top !
  |===========                                                                                                       |   9%
| Tout comme les expressions arithmétiques, les expressions logiques peuvent être regroupées à l'aide de parenthèses et indiquer ainsi les priorités de calcul. Par exemple, le résultat de l'expression (TRUE ==
| TRUE) == TRUE sera bien TRUE.

...
  |==============                                                                                                    |  12%
| Testons cette propriété, essayez d'évaluer (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| Tu es au top !
  |==================                                                                                                |  16%
| L'opérateur d'égalité peut aussi servir à comparer des nombres. Utilisez-le pour savoir si 6 et 7 sont égaux.

> 6 == 7
[1] FALSE

| Dans le mille ! Bien joué !
  |=====================                                                                                             |  19%
| Le résultat de l'expression précédente est FALSE, parce 6 est plus petit que 7. Heureusement pour nous, nous pouvons aussi tester les inégalités pour savoir si un nombre est plus petit ou plus grand qu'un
| autre.

...
  |=========================                                                                                         |  22%
| L'opérateur plus petit que `<` teste si le nombre à gauche de l'opérateur est plus petit que le nombre à droite. Tapez une expression pour tester si 6 et plus petit que 7.

> 6 < 7
[1] TRUE

| C'est la bonne réponse !
  |============================                                                                                      |  25%
| Il existe aussi un opérateur plus petit ou égal à `<=` qui teste si l'expression à gauche est plus petite ou égale à l'expression à droite. Essayez de voir si 10 est plus petit ou égal à 10.

> 10 <= 10
[1] TRUE

| Your dedication is inspiring!
  |================================                                                                                  |  28%
| On peut aussi utiliser les opérateurs plus grand que `>` et plus grand ou égal à `>=`.

...
  |====================================                                                                              |  31%
| Voyons si vous avez compris. Laquelle des expressions suivantes à pour résultat FALSE ?

1: 7 == 7
2: 6 < 8
3: 9 >= 10
4: 0 > -36

Sélection : 3

| Perseverance, that's the answer.
  |=======================================                                                                           |  34%
| Et maintenant, laquelle des expressions suivantes à pour résultat TRUE ?

1: -6 > -7
2: 7 == 9
3: 57 < 8
4: 9 >= 10

Sélection : 1

| Continue comme ça !
  |===========================================                                                                       |  38%
| Intéressons maintenant à l'opérateur 'différent de' (= non-égal) représenté par `!=`. Différent de teste si deux valeurs sont différentes, de telle sorte que le résultat de TRUE != FALSE est TRUE. Tout comme
| l'opérateur égalité, l'opérateur différent de s'utilise aussi avec des nombres. Essayez d'écrire une expression pour savoir si 5 est différent de 7.

> 5 !=7
[1] TRUE

| Excellent travail !
  |==============================================                                                                    |  41%
| Il peut être utile de 'négativer' une expression avec l'opérateur NON. Un point d'exclamation `!` inversera les évaluations de TRUE et FALSE, de telle sorte que la valeur de !TRUE (lire : non TRUE) est FALSE et
| que la valeur de !FALSE (lire : non FALSE) est TRUE. Essayez d'utiliser l'opéraeur NON pour trouver l'inverse de 5 est égal à 7.

> 
> ! 5 == 7
[1] TRUE

| Bravo!
  |==================================================                                                                |  44%
| Récapitulons. L'opérateur égal `==` teste si deux valeurs sont égales. L'opérateur différent de `!=` teste si deux valeurs sont différentes. L'opérateur NON `!` négative une expression logique de telle manière
| que TRUE devient FALSE et FALSE devient TRUE.

...
  |=====================================================                                                             |  47%
| Laquelle des expressions suivante est FALSE ?

1: 7 != 8
2: !(0 >= -1)
3: !FALSE
4: 9 < 10

Sélection : 2

| Perseverance, that's the answer.
  |=========================================================                                                         |  50%
| Quel est à votre avis le résultat de l'expression suivante : (TRUE != FALSE) == !(6 == 7)

1: TRUE
2: Y a-t-il une vérité objective dans la programmation ?
3: %>%
4: FALSE

Sélection : 3

| One more time. You can do it!

| Essayez d'évaluer les expressions indépendamment pour trouver le résultat.

1: FALSE
2: %>%
3: Y a-t-il une vérité objective dans la programmation ?
4: TRUE

Sélection : 4

| Tu es extraordinaire !
  |=============================================================                                                     |  53%
| Il est parfois nécessaire d'examiner les relations entre plusieurs expressions logiques. On utilise pour cela les opérateurs ET (AND) et OU (OR).

...
  |================================================================                                                  |  56%
| Regardons comment l'opérateur ET fonctionne. Il y a deux opérateurs ET dans R, `&` et `&&`. Les deux opérateurs sont similaires. Si les expressions à droite et à gauche de l'opérateur ET ont toutes les deux
| pour résultat TRUE, alors l'expression entière a pour résultat TRUE, sinon le résultat est FALSE. Par exemple, la valeur de TRUE & TRUE est TRUE. Essayez avec FALSE & FALSE.

> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| Try again. Getting it right on the first try is boring anyway! ou tape info() pour plus d'options.

| Tapez simplement FALSE & FALSE

> FALSE & FALSE
[1] FALSE

| Quelle maîtrise !
  |====================================================================                                              |  59%
| Vous pouvez utilisez l'opérateur `&` pour évaluer ET suivant un vecteur. La version `&&` a besoin d'avoir une seule valeur logique à gauche et à droite pour fonctionner. Essayons les deux. Commencez par TRUE &
| c(TRUE, FALSE, FALSE).

> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| Excellent work!
  |=======================================================================                                           |  62%
| L'expression de gauche est recyclée (rappelez-vous la leçon sur les vecteurs) afin d'avoir la même longueur que le vecteur de droite. C'est comme si on avait écrit c(TRUE, TRUE, TRUE) & c(TRUE, FALSE, FALSE).
| Une expression comme cela fonctionnera différemment avec l'opérateur `&&`, R bloquant le recyclage du vecteur de gauche (et renvoit une alerte depuis la version 4.2.0).

...
  |===========================================================================                                       |  66%
| Utilisons la même opération en remplaçant `&` par `&&`.

> c(TRUE, TRUE, TRUE) && c(TRUE, FALSE, FALSE)
[1] TRUE
Messages d'avis :
1: Dans c(TRUE, TRUE, TRUE) && c(TRUE, FALSE, FALSE) :
  ‘length(x) = 3 > 1’ dans la conversion automatique vers ‘logical(1)’
2: Dans c(TRUE, TRUE, TRUE) && c(TRUE, FALSE, FALSE) :
  ‘length(x) = 3 > 1’ dans la conversion automatique vers ‘logical(1)’

| Not quite, but you're learning! Try again. ou tape info() pour plus d'options.

| Tapez TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE
Message d'avis :
Dans TRUE && c(TRUE, FALSE, FALSE) :
  ‘length(x) = 3 > 1’ dans la conversion automatique vers ‘logical(1)’

| All that practice is paying off!
  |==============================================================================                                    |  69%
| R nous renvoit un Warning et le résultat ! Un message commençant par Warning est une façon de communiquer pour R. R vous communique que l'opération que vous êtes en train de faire est possible (il vous donne un
| résultat), mais qu'elle lui semble suspecte. En fait, ici R utilise uniquement le premier élément du vecteur de droite. Ce comportement est amené à disparaître dans les futures versions de R, je ne vous
| encourage donc pas à l'utiliser. Le principal intérêt de l'opérateur `&&` est de vous garantir que le résultat a une longueur de 1. Cela nous servira dans la suite du cours.

...
  |==================================================================================                                |  72%
| L'opérateur OU fonctionne d'une manière similaire. `|` recycle les vecteurs si besoin, alors que `||` renvoit un résultat de longueur 1.

...
  |======================================================================================                            |  75%
| OU renvoit TRUE si l'expression de droite ou l'expression de gauche est TRUE. Il renvoit FALSE sinon.

...
  |=========================================================================================                         |  78%
| Testons la version vectorielle de OU. Tapez la commande TRUE | c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| Bravo!
  |=============================================================================================                     |  81%
| Les opérateurs logiques peuvent être chainés, tout comme les opérations arithmétiques. Les expressions `6 != 10 && FALSE && 1 >= 2` ou `TRUE || 5 < 9.3 || FALSE` sont tout à fait normales.

...
  |================================================================================================                  |  84%
| Les opérations arithmétiques ont un ordre de priorité. Il en est de même pour les expressions logiques. Tous les opérateurs ET sont évalués avant les opérateurs OU. Essayez cet exemple un peu ambigu 5 > 8 || 6
| != 8 && 4 > 3.9.

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| Tu es au top !
  |====================================================================================================              |  88%
| Regardons l'ordre des opérations dans cet exemple. ET est prioritaire sur OU. On commence donc par évaluer les expressions à gauche et à droite de &&. 6 est bien différent de 8, donc le résultat à gauche est
| TRUE. 4 est bien plus grand que 3.9, donc le résultat à droite est aussi TRUE. Le résultat de TRUE && TRUE est TRUE. On peut maintenant regarder ce qui se passe autour de ||. À droite, on a TRUE, à gauche, 5
| n'est pas plus grand que 8, donc le résultat est FALSE. FALSE || TRUE a pour résultat TRUE, ce qui nous donne bien le résultat final.

...
  |=======================================================================================================           |  91%
| Quelle expression a pour résultat TRUE ?

1: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
2: TRUE && FALSE || 9 >= 4 && 3 < 6
3: FALSE || TRUE && FALSE
4: TRUE && 62 < 62 && 44 >= 44

Sélection : 2

| Bon boulot !
  |===========================================================================================================       |  94%
| Quelle expression a pour résultat FALSE ?

1: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
2: FALSE || TRUE && 6 != 4 || 9 > 4
3: 6 >= -9 && !(6 > 7) && !(!TRUE)
4: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5

Sélection : 3

| Ce n'est pas la bonne réponse, mais cherche encore.

| Si vous ne trouvez pas la réponse, essayez chaque expression pour en lire le résultat.

1: FALSE || TRUE && 6 != 4 || 9 > 4
2: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
3: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
4: 6 >= -9 && !(6 > 7) && !(!TRUE)

Sélection : 4

| Bien tenté, mais ce n'est pas exactement ce que j'espérais. Essaie à nouveau.

| Si vous ne trouvez pas la réponse, essayez chaque expression pour en lire le résultat.

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: FALSE || TRUE && 6 != 4 || 9 > 4
3: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
4: 6 >= -9 && !(6 > 7) && !(!TRUE)

Sélection : 1

| Bon boulot !
  |==============================================================================================================    |  97%
| C'est la fin de l'introduction à l'évaluation des expressions logiques dans R.

...
  |==================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui
| envoyer le fichier 'Logique.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Pas tout à fait ! Essaie à nouveau.

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 2

| C'est du bon boulot !

| Tu es arrivé(e) au bout de cette leçon! Retour au menu principal...

| Choisis un cours ou tape 0 pour quitter Swirl.

1: InitiationR
2: Montre-moi le répertoire des cours Swirl !

Sélection : 1

| Choisis une leçon ou tape 0 pour retourner au menu principal.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   


Sélection : 7

| Attempting to load lesson dependencies...

| Le paquet ‘base64enc’ a été chargé correctement !
  |                                                                                                                                                                                                           |   0%

| Les valeurs manquantes jouent un rôle important en statistiques et en analyse de données. Il arrive que les valeurs manquantes ne doivent pas être ignorée, mais au contraire étudiez avec attention.

...
  |==========                                                                                                                                                                                                 |   5%
| Dans R, les valeurs manquantes sont représentées par la valeur NA (not available en anglais). Dans d'autres langages, cela peut être missing plutôt. Dans cette leçon, nous allons voir comment traiter les
| valeurs manquantes.

...

  |===================                                                                                                                                                                                        |  10%
| N'importe quelle opération dans laquelle NA existe abouti à un résultat NA. Pour illustrer cela, créez le vecteur c(44, NA, 5, NA) et assigné le à l'objet x.

> x <- c(44, NA, 5, NA)

| Keep working like that and you'll get there!
  |=============================                                                                                                                                                                              |  14%
| Multiplions x par 3.

> x*3
[1] 132  NA  15  NA

| C'est du bon boulot !
  |=======================================                                                                                                                                                                    |  19%
| Remarquez que dans le résultat affiché, les valeurs NA correspondent aux valeurs où x est lui-même NA.

...
  |================================================                                                                                                                                                           |  24%
| Afin de rendre le problème un peu plus intéressant, nous allons créer un vecteur contenant 1000 tirages issue d'une distribution normale centrée réduite et les assigner à l'objet y. Utilisez pour cela la
| commande y <- rnorm(1000).

> y <- rnorm(1000)

| Excellent travail !
  |==========================================================                                                                                                                                                 |  29%
| Créons maintenant un vecteur contenant 1000 NA avec z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| Tu assures !
  |====================================================================                                                                                                                                       |  33%
| Enfin, sélectionnons 100 valeurs provenant des vecteurs y et z au hasard, afin de ne pas savoir combien il y a d'élément manquants dans le vecteur final, ni leur position. Pour cela, on utilise la commande data
| <- sample(c(y, z), 100)

> data <- sample(c(y, z), 100)

| Tu assures !
  |=============================================================================                                                                                                                              |  38%
| Commençons par identiifer où se trouve nos NA dans les données. La commande is.na() nous dit si chaque élément d'un vecteur est NA. Utilisez is.na() sur data et assignez le résultat à my_na.

> my_na <- is.na(data)

| Quelle maîtrise !
  |=======================================================================================                                                                                                                    |  43%
| Affichez maintenant my_na.

> my_na
  [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE
 [35] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE
 [69] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE

| Excellent travail !
  |=================================================================================================                                                                                                          |  48%
| À chaque fois que vous voyez TRUE, vous savez que l'élément correspondant dans data est une NA. À l'inverse, quand vous voyez FALSE, l'élément correspond est un des nombre issu du tirage aléatoire.

...
  |==========================================================================================================                                                                                                 |  52%
| Dans la leçon sur les opérateurs logiques, nous avons vu l'opérateur égalité `==`. Il test l'égalité entre deux objets. On peut penser que data == NA aboutira au même résultat que is.na(). Essayez pour voir !

> data == na
Erreur : objet 'na' introuvable
> data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [70] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| Quel talent !
  |====================================================================================================================                                                                                       |  57%
| Le résultat est un vecteur contenant uniquement des NA. L'explication pour cela est assez simple. NA n'est pas une valeur en soi, mais un symbole qui indique l'absence de valeur. L'opération logique paraît donc
| incomplète à R. On lui demande de comparer une valeur inexistance avec un vecteur de valeurs. Il ne peut que retourner l'absence de valeur.

...
  |==============================================================================================================================                                                                             |  62%
| Les NA peuvent être déroutante au début. Ne vous inquiétez pas si tout n'est pas très clair. Le point important à retenir que quand vous êtes face à des valeurs manquantes (NA), soyez prudent, cela peut vous
| donner des résultats inattendus.

...
  |=======================================================================================================================================                                                                    |  67%
| Fin de la parenthèse. Nous avons un vecteur, my_na, qui prend comme valeur TRUE pour chaque NA dans les données et FALSE pour toutes les valeurs numériques. Nous pouvons calculer le nombre de NA dans notre
| vecteur de données data.

...
  |=================================================================================================================================================                                                          |  71%
| Il y a une astuce qui va nous faire gagner du temps. R traîte les FALSE comme des 0 et les TRUE comme des 1. Il nous suffit donc de calculer la somme totale du vecteur my_na pour connaître le nombre de valeurs
| NA.

...
  |===========================================================================================================================================================                                                |  76%
| Essayons. Utilisez la commande sum() sur le vecteur my_na pour compter le nombre total de TRUE dans my_na, et donc le nombre total de NA dans data. Seul le résultat nous intéresse.

> sum(my_na)
[1] 48

| Continue comme ça !
  |====================================================================================================================================================================                                       |  81%
| Pratique, n'est-ce pas ? Enfin, pour vous convaincre que tout fonctionne bien, regardons les données. Affichez data dans la console.

> data
  [1]  1.06848823          NA  2.24403897          NA -0.32403109  1.57898418  0.29482600          NA          NA          NA  0.24331665          NA          NA          NA  0.03502969 -1.29243467          NA
 [18]          NA          NA          NA -0.40510454          NA -0.51451241  1.74043879 -1.19581599 -0.52225189  0.67072531          NA -1.62980941  0.35351011  2.34659295          NA  0.96282004          NA
 [35] -1.03330950 -1.96396070 -1.65949441          NA          NA          NA  0.14551992  0.51031103          NA -2.28066355  0.40459868  0.15018364          NA          NA -0.47982322 -0.85895518  1.87274436
 [52] -0.26442174  0.88197966  2.02259003 -1.12357430          NA          NA          NA  0.59258931          NA  0.63481216  0.21492134 -0.03973581          NA  0.27867779          NA -0.86871666  0.73134451
 [69] -0.82001064 -0.90430243 -0.35722537          NA          NA          NA -0.88774738 -0.94213406          NA          NA -1.47885162 -0.34600095 -0.83113630  0.34443916  0.04008554          NA          NA
 [86]  0.56850761          NA          NA          NA          NA          NA          NA          NA -0.22164707          NA          NA          NA          NA          NA          NA

| All that practice is paying off!
  |==============================================================================================================================================================================                             |  86%
| Il existe un second type de valeurs manquates, NaN (de l'anglais 'not a number'. Pour créer un NaN, essayez de diviser 0 par 0.

> 0/0
[1] NaN

| Tu es au top !
  |========================================================================================================================================================================================                   |  90%
| Une deuxième façon de créer des NaN. R a un symbole pour l'infini mathématiques, Inf. Que se passe-t-il si on soustrait Inf de Inf ?

> Inf - Inf
[1] NaN

| Excellent work!
  |=================================================================================================================================================================================================          |  95%
| Les NaN sont, vous l'aurez compris, un peu différent des NA. Ils ne nous indiquent pas l'absence de valeur général, mais le fait que le résultat de l'opération demandée n'est pas un nombre (une division par 0)
| et ne peut donc être calculé au sens classique du terme.

...
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui
| envoyer le fichier 'Valeurs_manquantes.txt' qui a été créé plus tard.

1: Oui
2: Non

Sélection : 1

| Continue ! Tu trouveras !

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 2

| C'est du bon boulot !

| Tu es arrivé(e) au bout de cette leçon! Retour au menu principal...

| Choisis un cours ou tape 0 pour quitter Swirl.

1: InitiationR
2: Montre-moi le répertoire des cours Swirl !

Sélection : 1

| Choisis une leçon ou tape 0 pour retourner au menu principal.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   


Sélection : 8

| Attempting to load lesson dependencies...

| Le paquet ‘base64enc’ a été chargé correctement !
  |                                                                                                                                                                                                           |   0%

| Nous allons maintenant étudier la création de vecteurs numériques.

...
  |=========                                                                                                                                                                                                  |   4%
| La manière la plus simple de créer un vecteur numérique dans R est d'utiliser la commande `:`. Tapez 1:20 pour voir comment elle fonctionne.

> 1:20
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| All that practice is paying off!
  |==================                                                                                                                                                                                         |   9%
| Nous avons crée un vecteur contenant (et incluant)tous les entiers entre 1 et 20. La commande fonctionne aussi avec des nombres réels. Essayez par exemple pi:10.

> pi:10
[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

| C'est du bon boulot !
  |==========================                                                                                                                                                                                 |  13%
| Le résultat est un vecteur de nombre réels commençant à pi (3.142...) et croissant par incrément de 1. La limite haute 10 n'est jamais atteinte, puisque le prochain nombre dans la séquence serait strictement
| supérieur à 10.

...
  |===================================                                                                                                                                                                        |  17%
| Que se passe-t-il si nous tapons 15:1 ? Essayez pour voir.

> 15:1
 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

| Tu assures !
  |============================================                                                                                                                                                               |  22%
| R utilise un incrément de -1 ! Ce comportement est parfois utile, gardez-le en tête.

...
  |=====================================================                                                                                                                                                      |  26%
| Pour accéder à l'aide sur une commande, vous pouvez utiliser un point d'interrogation suivi du nom de la commande. Il y a une exception néanmoins, le cas d'un opérateur tel que :. Il est nécessaire de mettre
| l'opérateur entre guillemets, comme ceci : ?':'.

...
  |==============================================================                                                                                                                                             |  30%
| Essayez d'obtenir la documentation pour : maintenant.

> maintenant
Erreur : objet 'maintenant' introuvable
> '??maintenant'
[1] "??maintenant"

| Ce n'est pas la bonne réponse, mais cherche encore. ou tape info() pour plus d'options.

| Tapez ?':'.

> ? ':'

| Tu es au top !
  |=======================================================================                                                                                                                                    |  35%
| Il est parfois utile d'avoir plus de contrôle sur la création de vecteurs numériques que permis par l'opérateur :. La fonction seq() sert exactement à cela.

...
  |===============================================================================                                                                                                                            |  39%
| Dans sa forme la plus simple, seq() remplit exactement le même rôle que `:`. Essayez seq(1, 20).

> seq(1,20)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| Quelle maîtrise !
  |========================================================================================                                                                                                                   |  43%
| Nous avons le même résultat qu'avec 1:20, peu intéressant... Imaginons maintenant que vous souhaitez créer un vecteur de nombre allant de 0 à 10 par incrément de 0.5. seq(0, 10, by=0.5) fait exactement cela.
| Essayez !

> seq(0, 10, by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0

| Tu es au top !
  |=================================================================================================                                                                                                          |  48%
| Parfois, ce n'est pas l'incrément qui compte, mais d'obtenir un vecteur avec une longueur donnée, par exemple, 30 nombres entre 5 et 10. seq(5, 10, length=30) sert exactement à cela. Essayez et stockez le
| résultat dans un nouvel objet appelé ma_seq.

> seq(5, 10, length=30)
 [1]  5.000000  5.172414  5.344828  5.517241  5.689655  5.862069  6.034483  6.206897  6.379310  6.551724  6.724138  6.896552  7.068966  7.241379  7.413793  7.586207  7.758621  7.931034  8.103448  8.275862
[21]  8.448276  8.620690  8.793103  8.965517  9.137931  9.310345  9.482759  9.655172  9.827586 10.000000

| Pas tout à fait ! Essaie à nouveau. ou tape info() pour plus d'options.

| Vous utilisez exactement la même commande que tout à l'heure, mais avec des arguments différent. Sauvegardez bien le résultat dans un nouvel objet ma_seq, comme ceci ma_seq <- seq(5, 10, length=30).

> ma_seq <- seq(5, 10, length=30)

| All that hard work is paying off!
  |==========================================================================================================                                                                                                 |  52%
| La fonction length() permet de connaître la longueur d'un objet dans R. Essayez-la sur le vecteur ma_seq pour vérifier qu'il contient bien 30 éléments.

> length(ma_seq)
[1] 30

| Excellent work!
  |===================================================================================================================                                                                                        |  57%
| Imaginons que nous ne connaissions pas la longueur de ma_seq, mais que nous voulons générer un vecteur de même longueur que le vecteur ma_seq et contenant les N premiers entiers. Autrement nous voulons générer
| un vecteur (1, 2, 3, ... N) ou N est la longueur de ma_seq.

...
  |============================================================================================================================                                                                               |  61%
| Il y a plusieurs manière de faire pour aboutir à ce résultat. La première est de combiner l'opérateur : et la fonction length(), comme ceci : 1:length(ma_seq). Essayez.

> 1:length(ma_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| Bon boulot !
  |====================================================================================================================================                                                                       |  65%
| Il est aussi possible d'utiliser une autre option de la fonction seq(), along.with, comme ceci : seq(along.with = ma_seq). L'argument along.with dit à R que vous voulez un vecteur de même longeur que ma_seq.
| Essayez.

> seq(along.with = ma_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| All that practice is paying off!
  |=============================================================================================================================================                                                              |  70%
| Mieux encore, comme pour beaucoup de tâches courantes, R dispose d'une commande spécifique, la fonction seq_along(). Tapez seq_along(ma_seq) pour la voir en action.

> seq_along(ma_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| C'est du bon boulot !
  |======================================================================================================================================================                                                     |  74%
| Il y a souvent plusieurs manières de résoudre le même problème dans R. Les approches simples qui requièrent le moins de lignes de code sont généralement les meilleures. Il est aussi important que votre code
| soit lisible pour que d'autres puissent le lire.

...
  |===============================================================================================================================================================                                            |  78%
| Si R dispose d'une fonction spécifique pour la tâche que vous souhaitez accomplir, c'est généralement votre meilleure option. Vous allez apprendre à créer vos propres fonctions quand vous ne trouverez pas ce
| qu'il vous faut dans R. Nous allons en explorer l'écriture dans une prochaine leçon.

...
  |========================================================================================================================================================================                                   |  83%
| Une dernière fonction qui peut être utile pour créer des vecteurs numériques est la fonction rep() (abréviation de "replicate" en anglais). Nous allons examiner quelques possibilités offertes par cette
| fonction.

...
  |=================================================================================================================================================================================                          |  87%
| Si nous voulons créer un vecteur contenant 40 zéros, nous pouvons le faire à l'aide de la commande rep(0, times = 40). Essayez.

> rep(0, times = 40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

| C'est du bon boulot !
  |=========================================================================================================================================================================================                  |  91%
| Une autre utilisation de la fonction rep() est pour créer un vecteur contenant 10 répétition du vecteur (0, 1, 2). Pour cela, tapez rep(c(0, 1, 2), times = 10).

> rep(c(0, 1, 2), times= 10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

| Dans le mille ! Bien joué !
  |==================================================================================================================================================================================================         |  96%
| Enfin, imaginons que plutôt que de répéter le vecteur (0, 1, 2) 10 fois, nous voulons un vecteur qui contiennent 10 zéros, puis 10 un, puis 10 deux. R nous permet de faire ça à l'aide de l'argument each de la
| fonction rep(). Essayez rep(c(0, 1, 2), each = 10).

> rep(c(0, 1, 2), each = 10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

| Dans le mille ! Bien joué !
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui
| envoyer le fichier 'Vecteurs_numeriques.txt' qui a été créé plus tard.

1: Non
2: Oui

Sélection : 2

| Ce n'est pas la bonne réponse, mais cherche encore.

| Cela soumettra votre avancée dans le cours.

1: Non
2: Oui

Sélection : 1

| Bravo!

| Tu es arrivé(e) au bout de cette leçon! Retour au menu principal...

| Choisis un cours ou tape 0 pour quitter Swirl.

1: InitiationR
2: Montre-moi le répertoire des cours Swirl !

Sélection : 1

| Choisis une leçon ou tape 0 pour retourner au menu principal.

 1: Manipulations simples           2: Assignations et objets          3: Types                           4: Vecteurs                        5: Fichiers et espace de travail   6: Logique                      
 7: Valeurs manquantes              8: Vecteurs numériques             9: Dataframes                     10: Scripts et fonctions           11: Control Flow                   12: Representations graphiques   


Sélection : 9

| Attempting to load lesson dependencies...

| Le paquet ‘base64enc’ a été chargé correctement !
  |                                                                                                                                                                                                           |   0%

| Nous avons vu comment créer des vecteurs contenant différentes valeurs, et différent types de valeurs. Il est parfois utile de les regrouper en une seule base de données. C'est à cela que nous servirons les
| dataframes.

...
  |==========                                                                                                                                                                                                 |   5%
| Nous avons vu que nous pouvons créer un vecteur à l'aide de la commande c(). Reprenez le vecteur contenant les tailles de la leçon précédente. Pour mémoire, nous souhaitons créer le vecteur contenant les
| tailles 156, 164, 197, 147 et 173 (dans cet ordre). Stockez le résultat dans l'objet tailles.

> c(156, 164, 197, 147, 173)
[1] 156 164 197 147 173

| One more time. You can do it! ou tape info() pour plus d'options.

| Tapez tailles <- c(156, 164, 197, 147, 173) et appuyez sur entrée.

> tailles <- c(156, 164, 197, 147, 173)

| Excellent travail !
  |===================                                                                                                                                                                                        |  10%
| Recréons maintenant le vecteur poids de la leçon sur les vecteurs. Pour mémoire, nous souhaitons créer le vecteur contenant les poids 45, 59, 110, 44 et 88 (dans cet ordre). Stockez le résultat dans l'objet
| poids.

> poids <- c(45, 59, 110, 44, 88)

| Continue comme ça !
  |=============================                                                                                                                                                                              |  14%
| Nous avons maintenant nos deux vecteurs de données, mais ils ne sont pas vraiment liés entre eux. Nous savons que la première taille correspond au premier poids, la seconde au second, etc. Nous pouvons même
| créer un vecteur de noms associés.

...
  |=======================================                                                                                                                                                                    |  19%
| Attribuons des noms à ces poids et tailles maintenant. Disons que ce sont les caractéristiques de Jeanne, Mohammed, Bassirou, Leila et Zoé. On peut créer un vecteur noms contenant ces noms (sans oublier les
| accents). Faites-le maintenant.

> noms <- c("Jeanne", "Mohammed", "Bassirou", "Leila", "Zoé")

| Tu es au top !
  |================================================                                                                                                                                                           |  24%
| Nous n'avons toujours pas liés nos données. Il n'est pas simple de trouver le poids et la taille de Bassirou par exemple. Pour simplifier cela, R possède un type, le data.frame, qui regroupe les données sous
| forme de tableaux.

...
  |==========================================================                                                                                                                                                 |  29%
| Il est possible de donner des noms aux lignes, ou pas. Ici, il est pratique pour nous d'attribuer le nom des personnes aux lignes, mais cela ne sera pas toujours le cas. La commande pour regrouper les données
| dans un tableau est data.frame. Pour ce que nous souhaitons faire, il faut taper data.frame(tailles, poids, row.names=noms). Nous souhaitons de plus stocker le dataframe dans l'objet data.

> data
  [1]  1.06848823          NA  2.24403897          NA -0.32403109  1.57898418  0.29482600          NA          NA          NA  0.24331665          NA          NA          NA  0.03502969 -1.29243467          NA
 [18]          NA          NA          NA -0.40510454          NA -0.51451241  1.74043879 -1.19581599 -0.52225189  0.67072531          NA -1.62980941  0.35351011  2.34659295          NA  0.96282004          NA
 [35] -1.03330950 -1.96396070 -1.65949441          NA          NA          NA  0.14551992  0.51031103          NA -2.28066355  0.40459868  0.15018364          NA          NA -0.47982322 -0.85895518  1.87274436
 [52] -0.26442174  0.88197966  2.02259003 -1.12357430          NA          NA          NA  0.59258931          NA  0.63481216  0.21492134 -0.03973581          NA  0.27867779          NA -0.86871666  0.73134451
 [69] -0.82001064 -0.90430243 -0.35722537          NA          NA          NA -0.88774738 -0.94213406          NA          NA -1.47885162 -0.34600095 -0.83113630  0.34443916  0.04008554          NA          NA
 [86]  0.56850761          NA          NA          NA          NA          NA          NA          NA -0.22164707          NA          NA          NA          NA          NA          NA

| One more time. You can do it! ou tape info() pour plus d'options.

| N'oubliez pas d'attribuer le dataframe à l'objet data.

> skip()

| J'affiche la bonne réponse pour toi...

> data <- data.frame(tailles, poids, row.names=noms)

| Dans le mille ! Bien joué !
  |====================================================================                                                                                                                                       |  33%
| Tapons maintenant data pour observer comment R a stocké nos données.

> data
         tailles poids
Jeanne       156    45
Mohammed     164    59
Bassirou     197   110
Leila        147    44
Zoé          173    88

| Quelle maîtrise !
  |=============================================================================                                                                                                                              |  38%
| R a stocké tout data dans un seul tableau. Il a automatiquement donné comme nom de colonnes le noms des objets utilisés pour construire le dataframe. Vous remarquerez aussi que les noms ne sont pas précédés
| d'un nom de colonne. C'est parce que c'est l'unique colonne de noms de lignes.

...
  |=======================================================================================                                                                                                                    |  43%
| Si on veut accéder à une colonne de ce tableau, il y a plusieurs méthodes. La première consiste à utiliser le nom du dataframe, suivi du signe $ suivi du nom de la colonne. Essayez de voir les tailles.

> data$tailles
[1] 156 164 197 147 173

| Perseverance, that's the answer.
  |=================================================================================================                                                                                                          |  48%
| La deuxième permet de consulter n'importe quelle colonne à l'aide d'un indice, un peu comme on consulterait un élément d'un vecteur. Si on souhaite voir la colonne numéro 2 du dataframe, on tapera data[2].
| Essayez pour voir !

> data[2]
         poids
Jeanne      45
Mohammed    59
Bassirou   110
Leila       44
Zoé         88

| Tu es au top !
  |==========================================================================================================                                                                                                 |  52%
| Enfin, une dernière méthode utile est d'utiliser le nom des colonnes entre des crochets, plutôt que d'utiliser le signe $. La méthode d'accès est similaire à la précédente, sauf qu'au lieu d'utiliser l'indice
| de la colonne, il faut utiliser son nom. Essayez pour voir si vous avez compris.

> data["poids"]
         poids
Jeanne      45
Mohammed    59
Bassirou   110
Leila       44
Zoé         88

| Keep working like that and you'll get there!
  |====================================================================================================================                                                                                       |  57%
| Vous verrez qu'à l'usage, il est souvent plus facile d'utiliser le nom de la colonne pour la consulter. La raison est simple, vous ne saurez pas toujours dans quel ordre R ordonné les colonnes et vous allez
| parfois ajouter ou supprimer des colonnes à vos dataframes. Il est beaucoup plus simple de se rappeler du nom d'une colonne plutôt que de son numéro, surtout si celui-ci peut changer. La méthode avec le $ ne
| permet de consulter qu'une seule colonne à la fois. La troisième méthode permet au contraire de consulter plusieurs colonnes simultanément, en mettant tous les noms des colonnes dans un vecteur.

...
  |==============================================================================================================================                                                                             |  62%
| Tout comme les colonnes, il y a plusieurs méthodes pour consulter une ou plusieurs lignes. La plus simple est d'utiliser un numéro de ligne. La syntaxe est un peu différente des colonnes. En effet, en pratique
| R considère les dataframes comme des matrices (objets que nous n'avons pas étudiés), c'est à dire que chaque cellule du tableau est indexé par un numéro de ligne et un numéro de colonne. La ligne est donné par
| le premier indice, alors que la colonne est donné par le deuxième indice. Si on veut consulter la deuxième ligne par exemple, on doit entre data[2, ]. Essayez pour voir !

> data[2, ]
         tailles poids
Mohammed     164    59

| C'est du bon boulot !
  |=======================================================================================================================================                                                                    |  67%
| La virgule suivi de rien indique à R que nous souhaitons consulter toutes les colonnes associées à la deuxième ligne. Si maintenant nous souhaitons seulement consulter la première colonne de la deuxième ligne,
| essayez de deviner comment faire.

> data[2,1]
[1] 164

| Tu es au top !
  |=================================================================================================================================================                                                          |  71%
| Nous avons donné des noms au lignes précédemment. Il serait dommage de ne pas les utiliser. Si maintenant on veut retrouver les caractéristiques de Bassirou, on peut utiliser le nom de la ligne, comme nous
| avons utiliser le nom de la colonne. Essayez pour voir si vous avez compris.

> data["Bassirou", ]
         tailles poids
Bassirou     197   110

| Quelle maîtrise !
  |===========================================================================================================================================================                                                |  76%
| Il est bien sûr possible d'ajouter des colonnes à un dataframe après sa création. Si par exemple nous voulons ajouter la colonne imc à ce dataframe et refaire le calcul fait auparavant, il faut utiliser la
| syntaxe data$imc <- data$poids / (data$tailles / 100)^2. Les règles de calculs sur les lignes ou les colonnes de dataframe sont identiques à celle des vecteurs. On peut aussi appeler les colonnes avec des
| guillemets et des crochets, mais ce n'est pas très utile ici.

> data$imc <- data$poids / (data$tailles / 100)^2

| Keep working like that and you'll get there!
  |====================================================================================================================================================================                                       |  81%
| Observez maitenant data.

> data
         tailles poids      imc
Jeanne       156    45 18.49112
Mohammed     164    59 21.93635
Bassirou     197   110 28.34394
Leila        147    44 20.36189
Zoé          173    88 29.40292

| Excellent travail !
  |==============================================================================================================================================================================                             |  86%
| Remarquez que R a créé une nouvelle colonne, imc, qui est le résultat du calcul que nous lui avons demandé.

...
  |========================================================================================================================================================================================                   |  90%
| Il pourrait être intéressant de faire quelques statistiques sur les données que nous avons. Utilisez la fonction summary() de R surdata pour obtenir un résumé des caractéristiques de notre échantillon.

> summary(data)
    tailles          poids            imc       
 Min.   :147.0   Min.   : 44.0   Min.   :18.49  
 1st Qu.:156.0   1st Qu.: 45.0   1st Qu.:20.36  
 Median :164.0   Median : 59.0   Median :21.94  
 Mean   :167.4   Mean   : 69.2   Mean   :23.71  
 3rd Qu.:173.0   3rd Qu.: 88.0   3rd Qu.:28.34  
 Max.   :197.0   Max.   :110.0   Max.   :29.40  

| C'est la bonne réponse !
  |=================================================================================================================================================================================================          |  95%
| Ce sera tout sur cette leçon. Vous savez maintenant l'essentiel des principaux types que vous allez rencontrer dans R.

...
  |===========================================================================================================================================================================================================| 100%
| Souhaitez-vous soumettre votre progression sur Moodle à votre enseignant (cela ne fonctionnera que pour les étudiants de l'université Paris 8) ? Si vous ne le faites pas maintenant, vous pourrez toujours lui
| envoyer le fichier 'Dataframes.txt' qui a été créé plus tard.

1: Oui
2: Non

Sélection : 1

| Tu es tout près... Je le sens ! Encore une fois.

| Cela soumettra votre avancée dans le cours.

1: Oui
2: Non

Sélection : 