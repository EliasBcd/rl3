---
title: "Données et fonctions"
subtitle: "L3 économie-finance"
author: "Elias Bouacida"
format: 
  revealjs:
    embed-resources: true
lang: fr
institute: "Université Paris 8"
scrollable: true
date: 20/09/2023
date-format: long
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)
```

# Vecteurs

## Vecteurs

Imaginons qu'on a demandé la taille en centimètres de 5 personnes et qu'on souhaite calculer leur taille moyenne.

On pourrait créer autant d'objets que de tailles et calculer la moyenne :

```{r}
taille1 <- 156
taille2 <- 164
taille3 <- 197
taille4 <- 147
taille5 <- 173
(taille1 + taille2 + taille3 + taille4 + taille5) / 5
```

---

Ce n'est clairement pas pratique du tout. On va plutôt stocker l'ensemble de nos tailles dans un seul objet, un **vecteur**, avec la syntaxe suivante :

```{r}
tailles <- c(156, 164, 197, 147, 173)
```

où le `c()` veut dire "combine les valeurs suivantes dans un vecteur".

---

Si on affiche le contenu de cet objet, on voit qu'il contient bien l'ensemble des tailles saisies.

```{r}
tailles
```

## Opérations vectorielles

Si on applique une opération à un vecteur, celle-ci s'applique à toutes les valeurs qu'il contient. 

Si on veut la taille en mètres plutôt qu'en centimètres, on peut faire :

```{r}
tailles_m <- tailles/100
tailles_m
```

---

Imaginons maintenant qu'on a aussi demandé aux cinq mêmes personnes leur poids en kilos.

On peut créer un deuxième vecteur :

```{r}
poids <- c(45, 59, 110, 44, 88)
```

On peut alors effectuer des calculs utilisant nos deux vecteurs `tailles` et `poids`.

On peut, par exemple, calculer l'indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré :

```{r}
imc <- poids / (tailles / 100) ^ 2
imc
```

## Vecteurs et types {.incremental}

Un vecteur peut contenir des nombres, mais il peut aussi contenir du texte.

Imaginons qu'on a demandé aux 5 mêmes personnes leur type de chien préféré : on peut regrouper l'information dans un vecteur.

```{r}
chien <- "Chihuahua"
chiens_pref <-c("Doberman","Chihuahua","Husky","Bouvier Bernois","Labrador")
chiens_pref
```

. . .

Notez néanmoins qu'un vecteur ne peut contenir qu'un seul type de valeurs.  
Si plusieurs types de valeurs sont donnés à un vecteur, les valeurs seront automatiquement converties au type le plus large.

::: {.notes}
En général, le type le plus large est le type texte.
:::


## Opérations logiques et vecteurs

Notons qu'on peut comparer des éléments d'un vecteur et d'un objet ou d'une valeur.
Ici, nous testons l'égalité par exemple :

```{r}
chiens_pref==chien
tailles==147
tailles_m>1.6
```

::: {.notes}
Notons que pour `R`, en fait, un objet contenant une seule valeur et un vecteur contenant une seule valeur.
:::

## Vecteurs numériques

L'opérateur `:` permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous `R` :

```{r}
liste <- 1:10
liste

liste2 <- 10:1
liste2
```

---

Si nous voulons créer un vecteur qui ne soit pas limité aux nombres entiers et qui augmente de 0.1 à la fois, nous pouvons utiliser la fonction `seq()`.

```{r}
seq(from = 1.5, to = 2.2, by = 0.1)
```

## Sous-vecteurs

Pour extraire un sous-vecteur (subsetting), c'est-à-dire pour n'en choisir que certains éléments, nous utilisons des crochets, “`[]`”. Par exemple, `x[1]` renvoie le premier élément du vecteur `x`, et `x[3]` renvoie le troisième élément

```{r}
tailles
tailles[1]
tailles[3]
```

## Exclusions d'un élément

Nous pouvons également exclure les éléments correspondant à certains indices en les faisant précéder par un signe `-` .
```{r}
tailles[-2]
```

## Sous-ensembles

Enfin, on peut faire des sous-ensembles sur la base d'un vecteur d'indices.

```{r}
tailles[1:3]
tailles[c(1,3,4)]
```


Nous pourrions également utiliser un vecteur de valeurs logiques.

```{r}
z = c(TRUE, TRUE, FALSE, TRUE, FALSE)
tailles[z]

```

Ce qui est très pratique pour extraire un sous-vecteur des entrées respectant une condition logique : 
```{r}
tailles[tailles>160]
```

## Valeurs manquantes

Il peut arriver qu'il y ait des valeurs manquantes dans vos données. 
Ces valeurs manquantes sont symbolisées dans `R` par le symbole `r NA`.

```{r}
NA
```

Les valeurs manquantes sont "absorbantes". 
Toute opération avec une valeur manquante abouti à une valeur manquante :

```{r}
c(1, 5, NA) == NA
```

Remarquez que même l'opération d'égalité entre deux `NA` aboutit à un résultat `NA`.

## Traitement des valeurs manquantes

Pour savoir si une valeur est une valeur manquante, il faut utiliser la fonction `is.na()`.

```{r}
is.na(NA)
is.na(c(1, 5, NA))
```

Remarquez que `R` a automatiquement "vectorisé" la fonction `is.na` appliquée à un vecteur.

## Not a Number `r NaN`

```{r}
0 / 0
```

Un deuxième type de valeurs manquantes est `r NaN`. 
C'est le résultat que renvoi `R` quand vous demandez une opération impossible.
L'interprétation est ici que `R` ne sait pas faire le calcul (car il est impossible).
Remarquez que `R` connaît d'une certaine manière les limites :

```{r}
10/0
```

Mais :

```{r}
Inf / Inf
```

## Bases de données

Dans R, les bases de données sont des `data.frame`. Dans une `data.frame`, chaque **variable** est stockée comme une colonne, et chaque ligne est une **observation**.

Pour créer une `data.frame`, on utilise la fonction `data.frame()` :
```{r}
base <- data.frame(tailles, poids)
```

Il est possible d'avoir plusieurs bases de données ouvertes simultanément dans une session R. Pour se référer à une variable particulière d'une base, on utilise la syntaxe  `<nom de la base>$<nom de la variable>`

```{r}
mean(base$tailles)
range(base$poids)
```

Si on veut ajouter une variable à une base de données, on utilise la même syntaxe

```{r}
base$imc <- base$poids/(base$taille/100)^2
```


On peut aussi accéder à une colonne à l'aide de crochets :

```{r}
base["imc"]
```

## Lignes

Pour accéder à une ligne dans une base de donnée, il faut avoir recourir à une notation "matricielle" :

```{r}
base[2, ]
```

On lit ainsi la deuxième ligne des données.
Et aussi :

```{r}
base[2, "imc"]
```


# Fonctions

## Principes

Nous savons effectuer des opérations de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard.

Pour aller plus loin, nous devons aborder les **fonctions** qui sont, avec les **objets**, un deuxième concept de base de R. 
On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions.

Formellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat.

Prenons tout de suite un exemple. Si on veut connaître le nombre d'éléments du vecteur `tailles` que nous avons construit précédemment, on peut utiliser la fonction `length()`, de cette manière :
```{r}
length(tailles)
```

---

Ici, `length()` est  la fonction, on l'appelle en lui passant un argument entre parenthèses (ici notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d'éléments du vecteur passé en paramètre.

Autre exemple, les fonctions `min()` et `max()` retournent respectivement les valeurs minimales et maximales d'un vecteur de nombres.

```{r}
min(tailles)
max(tailles)
```
La fonction `mean()` calcule et retourne la moyenne d'un vecteur de nombres.

```{r}
mean(tailles)
```

Une fonction peut renvoyer d'autres types de résultats. Par exemple, la fonction `range()` (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum.

```{r}
range(tailles)
```


## Arguments

Une fonction peut prendre plusieurs arguments, dans ce cas on les indique entre parenthèses en les séparant par des virgules.

On a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction `c()`, qui combine l'ensemble de ses arguments en un vecteur
```{r}
tailles <- c(156,164,197,147,173)
```
Ici, `c()` est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs.

Supposons maintenant que dans notre vecteur tailles nous avons une *valeur manquante* (une personne a refusé de répondre, ou notre mètre mesureur était en panne).


```{r}
tailles <- c(156, 164, 197, NA, 173)
tailles
```


## Valeurs manquantes

Si on calcule maintenant la taille moyenne à l'aide de la fonction `mean()`, on obtient :
```{r}
mean(tailles)
```

En effet, R considère par défaut qu'il ne peut pas calculer la moyenne si une des valeurs n'est pas disponible.
Dans ce cas il considère que la moyenne est elle-même "non disponible" et renvoie donc `NA` comme résultat.

On peut cependant indiquer à `mean()` d'effectuer le calcul en ignorant les valeurs manquantes.
Ceci se fait en ajoutant un argument supplémentaire, nommé `na.rm` (abréviation de NA remove, "enlever les NA"), et de lui attribuer la valeur `TRUE`.

```{r}
mean(tailles, na.rm = TRUE)
```

Mettre le paramètre `na.rm` à `TRUE` indique à la fonction `mean()` de ne pas tenir compte des valeurs manquantes dans le calcul.

Remarquez qu'ici, nous avons nommé l'argument (`na.rm`).
De manière général, quand on passe un argument en faisant `nom = valeur`, on nomme l'argument.
Cela est utile quand on ne souvient pas de la position de l'argument dans la fonction.


## Valeur par défaut d'un argument

Le nommage des arguments est indissociable des arguments par défaut.
Dans la première version de `mean` que nous avons utilisé, la valeur de `na.rm` était implicitement  `FALSE`.
C'est en fait la valeur par défaut de l'argument `na.rm`.
Si nous ne donnons pas explicitement une valeur à `na.rm`, `R` utilisera la valeur `FALSE`.
Les valeurs par défaut des arguments sont très utiles pour éviter de rentrer systématiquement une valeur.

`log` a pour exemple comme valeur par défaut pour `base = exp(1)`, donnant ainsi le logarithme népérien en l'absence de précision.


## L'argument ...

Un dernier argument est souvent rencontré mais pas toujours expliqué dans `R`, l'argument `...`.
Cet argument permet de "capturer" toutes les valeurs rentrées.
Si vous rechercher l'aide sur la fonction `c`, vous remarquerez que c'est le premier argument.
Il permet aussi l'hérédité des arguments quand on construit une nouvelle fonction, vous le verrez en exercices.

## Aide sur une fonction

Il est fréquent de ne pas savoir (ou d'avoir oublié) quels sont les arguments d'une fonction, ou comment ils se nomment, ou quels sont les valeurs par défaut des arguments.
On peut à tout moment faire appel à l'aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction `help()`.
```{r eval=FALSE}
help("mean")
```

On peut aussi utiliser le raccourci `?` :

```{r eval=FALSE}
?mean
```


Ces deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples.
Ces pages d'aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d'une lecture aisée.




## Créer sa propre fonction

Vous serez probablement amené à créer vos propres fonctions dans `R`.
Voici l'exemple d'une fonction qui reproduirait `mean` :

```{r}
moyenne <- function(x, na.rm=FALSE){
  ## Calculs effectués par la fonctions, les caractères après un # sont ignorés
  res <- 0
  if (na.rm && (sum(is.na(x)) > 0)) {
     # if/else sont des conditions logiques, nous y reviendrons.
    res <- sum(x[!is.na(x)]) / sum(!is.na(x))
  }
  else {
    res <- sum(x) / length(x)
  }
  res # Résultat de la fonction
}
```


Définir une fonction, c'est attribuer au nom de la fonction (ici, `moyenne`) le mot clé `function` avec entre parenthèses les arguments, éventuellement nommés.
Les `{}` délimitent ensuite le code propre à la fonction.
La dernière ligne de la fonction est le résultat de celle-ci, qui est renvoyé.

::: {.notes}

- Mot clé `function` attribué au nom de la fonction
- `if / else` : si / sinon. 
Commencer à parler des conditions.
- `length` : longueur d'un vecteur
- `sum` : somme de toutes les valeurs d'un vecteur
:::


## Fonctions anonymes (fonctions lambda)

Il n'est pas nécessaire de nommer une fonction pour en créer une.
Il est possible de créer des fonctions anonymes, ce qui peut être utile dans le cas où vous passer une fonction comme argument d'une autre fonction.
La syntaxe est la suivante :

```{r}
(function(x) {x+1})(6)
```

Cette fonction ajoute 1 à l'élément passé comme argument.

On a ensuite évalué cette fonction en 6, d'où le résultat.

# Scripts

## Regrouper ses commandes dans des scripts

- Jusqu'ici on a utilisé R de manière "interactive", en saisissant des commandes directement dans la console. 
Ce n'est pas très pratique pour sauvegarder son travail ou créer des fonctions. 
Lorsque `R` ou RStudio redémarre, tout ce qui a été effectué dans la console est perdu.
- On va plutôt  regrouper les commandes dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées. 
En rouvrant les scripts et en réexécutant les commandes qu'ils contiennent on pourra "reproduire" le chargement des données, leur traitement, les analyses et leurs résultats.
- Pour créer un script, il suffit de sélectionner le menu *Fichier* (File), puis *Nouveau fichier* (New File) et *script R* (R script).
Une quatrième zone apparaît alors en haut à gauche de l'interface de RStudio. 
On peut enregistrer notre script à tout moment dans un fichier avec l'extension .R, en cliquant sur l'icône de disquette ou en choisissant *Fichier* (File) puis *Sauvegarder* (Save) ou en utilisant le raccourci *Ctrl + S* (Cmd + S sous Mac).
- Un script est un fichier texte brut, qui s'édite de la manière habituelle. 
À la différence de la console, quand on appuie sur Entrée, cela n'exécute pas la commande en cours mais insère un saut de ligne.
- Pour exécuter une commande dans un script, il faut positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d'outils juste au-dessus de la zone d'édition du script. 
On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac).
On peut aussi sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l'ensemble des lignes est exécuté d'un coup.

---

Au final, un script pourra ressembler à quelque chose comme ça :

```{r eval = FALSE}
tailles <- c(156, 164, 197, 147, 173)
poids <- c(45, 59, 110, 44, 88)

mean(tailles)
mean(poids)

imc <- poids / (tailles / 100) ^ 2
min(imc)
max(imc)

```


## Commentaires

- Les commentaires sont un élément très important d'un script. 
Il s'agit de texte, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière...
Il est primordial de documenter ses scripts avec des commentaires, car il est très facile de ne plus se retrouver dans un programme qu'on a produit soi-même, même après une courte interruption.
- Pour ajouter un commentaire, il suffit de le faire précéder d'un ou plusieurs symboles `#`.
En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu'à la fin de la ligne.

On peut donc documenter le script précédent :

```{r, eval=FALSE}
# Saisie des tailles et poids des enquêtés
tailles <- c(156, 164, 197, 147, 173)
poids <- c(45, 59, 110, 44, 88)

# Calcul des tailles et poids moyens
mean(tailles)
mean(poids)

# Calcul de l'IMC (poids en kilo divisé par les tailles en mètre au carré)
imc <- poids / (tailles / 100) ^ 2
# Valeurs extrêmes de l'IMC
min(imc)
max(imc)
```

